{"mappings":"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","sources":["node_modules/kdbush/src/sort.js","node_modules/kdbush/src/range.js","node_modules/kdbush/src/within.js","node_modules/fast-deep-equal/index.js","node_modules/kdbush/src/index.js","node_modules/supercluster/index.js","node_modules/@googlemaps/markerclusterer/src/cluster.ts","node_modules/@googlemaps/markerclusterer/src/algorithms/utils.ts","node_modules/@googlemaps/markerclusterer/src/algorithms/core.ts","node_modules/@googlemaps/markerclusterer/src/algorithms/supercluster.ts","node_modules/@googlemaps/markerclusterer/src/renderer.ts","node_modules/@googlemaps/markerclusterer/src/overlay-view-safe.ts","node_modules/@googlemaps/markerclusterer/src/markerclusterer.ts","node_modules/@swc/helpers/lib/_define_property.js","src/js/points.js","src/js/modelObjectsHandler.js","src/js/createMap.js","src/js/createGallery.js","src/js/createForm.js","src/js/index.js"],"sourcesContent":["\nexport default function sortKD(ids, coords, nodeSize, left, right, depth) {\n    if (right - left <= nodeSize) return;\n\n    const m = (left + right) >> 1;\n\n    select(ids, coords, m, left, right, depth % 2);\n\n    sortKD(ids, coords, nodeSize, left, m - 1, depth + 1);\n    sortKD(ids, coords, nodeSize, m + 1, right, depth + 1);\n}\n\nfunction select(ids, coords, k, left, right, inc) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            const n = right - left + 1;\n            const m = k - left + 1;\n            const z = Math.log(n);\n            const s = 0.5 * Math.exp(2 * z / 3);\n            const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            select(ids, coords, k, newLeft, newRight, inc);\n        }\n\n        const t = coords[2 * k + inc];\n        let i = left;\n        let j = right;\n\n        swapItem(ids, coords, left, k);\n        if (coords[2 * right + inc] > t) swapItem(ids, coords, left, right);\n\n        while (i < j) {\n            swapItem(ids, coords, i, j);\n            i++;\n            j--;\n            while (coords[2 * i + inc] < t) i++;\n            while (coords[2 * j + inc] > t) j--;\n        }\n\n        if (coords[2 * left + inc] === t) swapItem(ids, coords, left, j);\n        else {\n            j++;\n            swapItem(ids, coords, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swapItem(ids, coords, i, j) {\n    swap(ids, i, j);\n    swap(coords, 2 * i, 2 * j);\n    swap(coords, 2 * i + 1, 2 * j + 1);\n}\n\nfunction swap(arr, i, j) {\n    const tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n","\nexport default function range(ids, coords, minX, minY, maxX, maxY, nodeSize) {\n    const stack = [0, ids.length - 1, 0];\n    const result = [];\n    let x, y;\n\n    while (stack.length) {\n        const axis = stack.pop();\n        const right = stack.pop();\n        const left = stack.pop();\n\n        if (right - left <= nodeSize) {\n            for (let i = left; i <= right; i++) {\n                x = coords[2 * i];\n                y = coords[2 * i + 1];\n                if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[i]);\n            }\n            continue;\n        }\n\n        const m = Math.floor((left + right) / 2);\n\n        x = coords[2 * m];\n        y = coords[2 * m + 1];\n\n        if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[m]);\n\n        const nextAxis = (axis + 1) % 2;\n\n        if (axis === 0 ? minX <= x : minY <= y) {\n            stack.push(left);\n            stack.push(m - 1);\n            stack.push(nextAxis);\n        }\n        if (axis === 0 ? maxX >= x : maxY >= y) {\n            stack.push(m + 1);\n            stack.push(right);\n            stack.push(nextAxis);\n        }\n    }\n\n    return result;\n}\n","\nexport default function within(ids, coords, qx, qy, r, nodeSize) {\n    const stack = [0, ids.length - 1, 0];\n    const result = [];\n    const r2 = r * r;\n\n    while (stack.length) {\n        const axis = stack.pop();\n        const right = stack.pop();\n        const left = stack.pop();\n\n        if (right - left <= nodeSize) {\n            for (let i = left; i <= right; i++) {\n                if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) result.push(ids[i]);\n            }\n            continue;\n        }\n\n        const m = Math.floor((left + right) / 2);\n\n        const x = coords[2 * m];\n        const y = coords[2 * m + 1];\n\n        if (sqDist(x, y, qx, qy) <= r2) result.push(ids[m]);\n\n        const nextAxis = (axis + 1) % 2;\n\n        if (axis === 0 ? qx - r <= x : qy - r <= y) {\n            stack.push(left);\n            stack.push(m - 1);\n            stack.push(nextAxis);\n        }\n        if (axis === 0 ? qx + r >= x : qy + r >= y) {\n            stack.push(m + 1);\n            stack.push(right);\n            stack.push(nextAxis);\n        }\n    }\n\n    return result;\n}\n\nfunction sqDist(ax, ay, bx, by) {\n    const dx = ax - bx;\n    const dy = ay - by;\n    return dx * dx + dy * dy;\n}\n","'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n","\nimport sort from './sort';\nimport range from './range';\nimport within from './within';\n\nconst defaultGetX = p => p[0];\nconst defaultGetY = p => p[1];\n\nexport default class KDBush {\n    constructor(points, getX = defaultGetX, getY = defaultGetY, nodeSize = 64, ArrayType = Float64Array) {\n        this.nodeSize = nodeSize;\n        this.points = points;\n\n        const IndexArrayType = points.length < 65536 ? Uint16Array : Uint32Array;\n\n        const ids = this.ids = new IndexArrayType(points.length);\n        const coords = this.coords = new ArrayType(points.length * 2);\n\n        for (let i = 0; i < points.length; i++) {\n            ids[i] = i;\n            coords[2 * i] = getX(points[i]);\n            coords[2 * i + 1] = getY(points[i]);\n        }\n\n        sort(ids, coords, nodeSize, 0, ids.length - 1, 0);\n    }\n\n    range(minX, minY, maxX, maxY) {\n        return range(this.ids, this.coords, minX, minY, maxX, maxY, this.nodeSize);\n    }\n\n    within(x, y, r) {\n        return within(this.ids, this.coords, x, y, r, this.nodeSize);\n    }\n}\n","\nimport KDBush from 'kdbush';\n\nconst defaultOptions = {\n    minZoom: 0,   // min zoom to generate clusters on\n    maxZoom: 16,  // max zoom level to cluster the points on\n    minPoints: 2, // minimum points to form a cluster\n    radius: 40,   // cluster radius in pixels\n    extent: 512,  // tile extent (radius is calculated relative to it)\n    nodeSize: 64, // size of the KD-tree leaf node, affects performance\n    log: false,   // whether to log timing info\n\n    // whether to generate numeric ids for input features (in vector tiles)\n    generateId: false,\n\n    // a reduce function for calculating custom cluster properties\n    reduce: null, // (accumulated, props) => { accumulated.sum += props.sum; }\n\n    // properties to use for individual points when running the reducer\n    map: props => props // props => ({sum: props.my_value})\n};\n\nconst fround = Math.fround || (tmp => ((x) => { tmp[0] = +x; return tmp[0]; }))(new Float32Array(1));\n\nexport default class Supercluster {\n    constructor(options) {\n        this.options = extend(Object.create(defaultOptions), options);\n        this.trees = new Array(this.options.maxZoom + 1);\n    }\n\n    load(points) {\n        const {log, minZoom, maxZoom, nodeSize} = this.options;\n\n        if (log) console.time('total time');\n\n        const timerId = `prepare ${  points.length  } points`;\n        if (log) console.time(timerId);\n\n        this.points = points;\n\n        // generate a cluster object for each point and index input points into a KD-tree\n        let clusters = [];\n        for (let i = 0; i < points.length; i++) {\n            if (!points[i].geometry) continue;\n            clusters.push(createPointCluster(points[i], i));\n        }\n        this.trees[maxZoom + 1] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n        if (log) console.timeEnd(timerId);\n\n        // cluster points on max zoom, then cluster the results on previous zoom, etc.;\n        // results in a cluster hierarchy across zoom levels\n        for (let z = maxZoom; z >= minZoom; z--) {\n            const now = +Date.now();\n\n            // create a new set of clusters for the zoom and index them with a KD-tree\n            clusters = this._cluster(clusters, z);\n            this.trees[z] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n            if (log) console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now);\n        }\n\n        if (log) console.timeEnd('total time');\n\n        return this;\n    }\n\n    getClusters(bbox, zoom) {\n        let minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\n        const minLat = Math.max(-90, Math.min(90, bbox[1]));\n        let maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\n        const maxLat = Math.max(-90, Math.min(90, bbox[3]));\n\n        if (bbox[2] - bbox[0] >= 360) {\n            minLng = -180;\n            maxLng = 180;\n        } else if (minLng > maxLng) {\n            const easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\n            const westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\n            return easternHem.concat(westernHem);\n        }\n\n        const tree = this.trees[this._limitZoom(zoom)];\n        const ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\n        const clusters = [];\n        for (const id of ids) {\n            const c = tree.points[id];\n            clusters.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n        }\n        return clusters;\n    }\n\n    getChildren(clusterId) {\n        const originId = this._getOriginId(clusterId);\n        const originZoom = this._getOriginZoom(clusterId);\n        const errorMsg = 'No cluster with the specified id.';\n\n        const index = this.trees[originZoom];\n        if (!index) throw new Error(errorMsg);\n\n        const origin = index.points[originId];\n        if (!origin) throw new Error(errorMsg);\n\n        const r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\n        const ids = index.within(origin.x, origin.y, r);\n        const children = [];\n        for (const id of ids) {\n            const c = index.points[id];\n            if (c.parentId === clusterId) {\n                children.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n            }\n        }\n\n        if (children.length === 0) throw new Error(errorMsg);\n\n        return children;\n    }\n\n    getLeaves(clusterId, limit, offset) {\n        limit = limit || 10;\n        offset = offset || 0;\n\n        const leaves = [];\n        this._appendLeaves(leaves, clusterId, limit, offset, 0);\n\n        return leaves;\n    }\n\n    getTile(z, x, y) {\n        const tree = this.trees[this._limitZoom(z)];\n        const z2 = Math.pow(2, z);\n        const {extent, radius} = this.options;\n        const p = radius / extent;\n        const top = (y - p) / z2;\n        const bottom = (y + 1 + p) / z2;\n\n        const tile = {\n            features: []\n        };\n\n        this._addTileFeatures(\n            tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom),\n            tree.points, x, y, z2, tile);\n\n        if (x === 0) {\n            this._addTileFeatures(\n                tree.range(1 - p / z2, top, 1, bottom),\n                tree.points, z2, y, z2, tile);\n        }\n        if (x === z2 - 1) {\n            this._addTileFeatures(\n                tree.range(0, top, p / z2, bottom),\n                tree.points, -1, y, z2, tile);\n        }\n\n        return tile.features.length ? tile : null;\n    }\n\n    getClusterExpansionZoom(clusterId) {\n        let expansionZoom = this._getOriginZoom(clusterId) - 1;\n        while (expansionZoom <= this.options.maxZoom) {\n            const children = this.getChildren(clusterId);\n            expansionZoom++;\n            if (children.length !== 1) break;\n            clusterId = children[0].properties.cluster_id;\n        }\n        return expansionZoom;\n    }\n\n    _appendLeaves(result, clusterId, limit, offset, skipped) {\n        const children = this.getChildren(clusterId);\n\n        for (const child of children) {\n            const props = child.properties;\n\n            if (props && props.cluster) {\n                if (skipped + props.point_count <= offset) {\n                    // skip the whole cluster\n                    skipped += props.point_count;\n                } else {\n                    // enter the cluster\n                    skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);\n                    // exit the cluster\n                }\n            } else if (skipped < offset) {\n                // skip a single point\n                skipped++;\n            } else {\n                // add a single point\n                result.push(child);\n            }\n            if (result.length === limit) break;\n        }\n\n        return skipped;\n    }\n\n    _addTileFeatures(ids, points, x, y, z2, tile) {\n        for (const i of ids) {\n            const c = points[i];\n            const isCluster = c.numPoints;\n\n            let tags, px, py;\n            if (isCluster) {\n                tags = getClusterProperties(c);\n                px = c.x;\n                py = c.y;\n            } else {\n                const p = this.points[c.index];\n                tags = p.properties;\n                px = lngX(p.geometry.coordinates[0]);\n                py = latY(p.geometry.coordinates[1]);\n            }\n\n            const f = {\n                type: 1,\n                geometry: [[\n                    Math.round(this.options.extent * (px * z2 - x)),\n                    Math.round(this.options.extent * (py * z2 - y))\n                ]],\n                tags\n            };\n\n            // assign id\n            let id;\n            if (isCluster) {\n                id = c.id;\n            } else if (this.options.generateId) {\n                // optionally generate id\n                id = c.index;\n            } else if (this.points[c.index].id) {\n                // keep id if already assigned\n                id = this.points[c.index].id;\n            }\n\n            if (id !== undefined) f.id = id;\n\n            tile.features.push(f);\n        }\n    }\n\n    _limitZoom(z) {\n        return Math.max(this.options.minZoom, Math.min(Math.floor(+z), this.options.maxZoom + 1));\n    }\n\n    _cluster(points, zoom) {\n        const clusters = [];\n        const {radius, extent, reduce, minPoints} = this.options;\n        const r = radius / (extent * Math.pow(2, zoom));\n\n        // loop through each point\n        for (let i = 0; i < points.length; i++) {\n            const p = points[i];\n            // if we've already visited the point at this zoom level, skip it\n            if (p.zoom <= zoom) continue;\n            p.zoom = zoom;\n\n            // find all nearby points\n            const tree = this.trees[zoom + 1];\n            const neighborIds = tree.within(p.x, p.y, r);\n\n            const numPointsOrigin = p.numPoints || 1;\n            let numPoints = numPointsOrigin;\n\n            // count the number of points in a potential cluster\n            for (const neighborId of neighborIds) {\n                const b = tree.points[neighborId];\n                // filter out neighbors that are already processed\n                if (b.zoom > zoom) numPoints += b.numPoints || 1;\n            }\n\n            // if there were neighbors to merge, and there are enough points to form a cluster\n            if (numPoints > numPointsOrigin && numPoints >= minPoints) {\n                let wx = p.x * numPointsOrigin;\n                let wy = p.y * numPointsOrigin;\n\n                let clusterProperties = reduce && numPointsOrigin > 1 ? this._map(p, true) : null;\n\n                // encode both zoom and point index on which the cluster originated -- offset by total length of features\n                const id = (i << 5) + (zoom + 1) + this.points.length;\n\n                for (const neighborId of neighborIds) {\n                    const b = tree.points[neighborId];\n\n                    if (b.zoom <= zoom) continue;\n                    b.zoom = zoom; // save the zoom (so it doesn't get processed twice)\n\n                    const numPoints2 = b.numPoints || 1;\n                    wx += b.x * numPoints2; // accumulate coordinates for calculating weighted center\n                    wy += b.y * numPoints2;\n\n                    b.parentId = id;\n\n                    if (reduce) {\n                        if (!clusterProperties) clusterProperties = this._map(p, true);\n                        reduce(clusterProperties, this._map(b));\n                    }\n                }\n\n                p.parentId = id;\n                clusters.push(createCluster(wx / numPoints, wy / numPoints, id, numPoints, clusterProperties));\n\n            } else { // left points as unclustered\n                clusters.push(p);\n\n                if (numPoints > 1) {\n                    for (const neighborId of neighborIds) {\n                        const b = tree.points[neighborId];\n                        if (b.zoom <= zoom) continue;\n                        b.zoom = zoom;\n                        clusters.push(b);\n                    }\n                }\n            }\n        }\n\n        return clusters;\n    }\n\n    // get index of the point from which the cluster originated\n    _getOriginId(clusterId) {\n        return (clusterId - this.points.length) >> 5;\n    }\n\n    // get zoom of the point from which the cluster originated\n    _getOriginZoom(clusterId) {\n        return (clusterId - this.points.length) % 32;\n    }\n\n    _map(point, clone) {\n        if (point.numPoints) {\n            return clone ? extend({}, point.properties) : point.properties;\n        }\n        const original = this.points[point.index].properties;\n        const result = this.options.map(original);\n        return clone && result === original ? extend({}, result) : result;\n    }\n}\n\nfunction createCluster(x, y, id, numPoints, properties) {\n    return {\n        x: fround(x), // weighted cluster center; round for consistency with Float32Array index\n        y: fround(y),\n        zoom: Infinity, // the last zoom the cluster was processed at\n        id, // encodes index of the first child of the cluster and its zoom level\n        parentId: -1, // parent cluster id\n        numPoints,\n        properties\n    };\n}\n\nfunction createPointCluster(p, id) {\n    const [x, y] = p.geometry.coordinates;\n    return {\n        x: fround(lngX(x)), // projected point coordinates\n        y: fround(latY(y)),\n        zoom: Infinity, // the last zoom the point was processed at\n        index: id, // index of the source feature in the original input array,\n        parentId: -1 // parent cluster id\n    };\n}\n\nfunction getClusterJSON(cluster) {\n    return {\n        type: 'Feature',\n        id: cluster.id,\n        properties: getClusterProperties(cluster),\n        geometry: {\n            type: 'Point',\n            coordinates: [xLng(cluster.x), yLat(cluster.y)]\n        }\n    };\n}\n\nfunction getClusterProperties(cluster) {\n    const count = cluster.numPoints;\n    const abbrev =\n        count >= 10000 ? `${Math.round(count / 1000)  }k` :\n        count >= 1000 ? `${Math.round(count / 100) / 10  }k` : count;\n    return extend(extend({}, cluster.properties), {\n        cluster: true,\n        cluster_id: cluster.id,\n        point_count: count,\n        point_count_abbreviated: abbrev\n    });\n}\n\n// longitude/latitude to spherical mercator in [0..1] range\nfunction lngX(lng) {\n    return lng / 360 + 0.5;\n}\nfunction latY(lat) {\n    const sin = Math.sin(lat * Math.PI / 180);\n    const y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\n    return y < 0 ? 0 : y > 1 ? 1 : y;\n}\n\n// spherical mercator to longitude/latitude\nfunction xLng(x) {\n    return (x - 0.5) * 360;\n}\nfunction yLat(y) {\n    const y2 = (180 - y * 360) * Math.PI / 180;\n    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\n}\n\nfunction extend(dest, src) {\n    for (const id in src) dest[id] = src[id];\n    return dest;\n}\n\nfunction getX(p) {\n    return p.x;\n}\nfunction getY(p) {\n    return p.y;\n}\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport interface ClusterOptions {\n  position?: google.maps.LatLng | google.maps.LatLngLiteral;\n  markers?: google.maps.Marker[];\n}\n\nexport class Cluster {\n  public marker: google.maps.Marker;\n  public readonly markers?: google.maps.Marker[];\n  protected _position: google.maps.LatLng;\n\n  constructor({ markers, position }: ClusterOptions) {\n    this.markers = markers;\n\n    if (position) {\n      if (position instanceof google.maps.LatLng) {\n        this._position = position;\n      } else {\n        this._position = new google.maps.LatLng(position);\n      }\n    }\n  }\n\n  public get bounds(): google.maps.LatLngBounds | undefined {\n    if (this.markers.length === 0 && !this._position) {\n      return undefined;\n    }\n\n    return this.markers.reduce((bounds, marker) => {\n      return bounds.extend(marker.getPosition());\n    }, new google.maps.LatLngBounds(this._position, this._position));\n  }\n\n  public get position(): google.maps.LatLng {\n    return this._position || this.bounds.getCenter();\n  }\n\n  /**\n   * Get the count of **visible** markers.\n   */\n  public get count(): number {\n    return this.markers.filter((m: google.maps.Marker) => m.getVisible())\n      .length;\n  }\n\n  /**\n   * Add a marker to the cluster.\n   */\n  public push(marker: google.maps.Marker): void {\n    this.markers.push(marker);\n  }\n\n  /**\n   * Cleanup references and remove marker from map.\n   */\n  public delete(): void {\n    if (this.marker) {\n      this.marker.setMap(null);\n      delete this.marker;\n    }\n    this.markers.length = 0;\n  }\n}\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport const filterMarkersToPaddedViewport = (\n  map: google.maps.Map,\n  mapCanvasProjection: google.maps.MapCanvasProjection,\n  markers: google.maps.Marker[],\n  viewportPadding: number\n): google.maps.Marker[] => {\n  const extendedMapBounds = extendBoundsToPaddedViewport(\n    map.getBounds(),\n    mapCanvasProjection,\n    viewportPadding\n  );\n  return markers.filter((marker) =>\n    extendedMapBounds.contains(marker.getPosition())\n  );\n};\n\n/**\n * Extends a bounds by a number of pixels in each direction.\n */\nexport const extendBoundsToPaddedViewport = (\n  bounds: google.maps.LatLngBounds,\n  projection: google.maps.MapCanvasProjection,\n  pixels: number\n): google.maps.LatLngBounds => {\n  const { northEast, southWest } = latLngBoundsToPixelBounds(\n    bounds,\n    projection\n  );\n  const extendedPixelBounds = extendPixelBounds(\n    { northEast, southWest },\n    pixels\n  );\n  return pixelBoundsToLatLngBounds(extendedPixelBounds, projection);\n};\n\n/**\n * @hidden\n */\nexport const distanceBetweenPoints = (\n  p1: google.maps.LatLngLiteral,\n  p2: google.maps.LatLngLiteral\n): number => {\n  const R = 6371; // Radius of the Earth in km\n  const dLat = ((p2.lat - p1.lat) * Math.PI) / 180;\n  const dLon = ((p2.lng - p1.lng) * Math.PI) / 180;\n  const a =\n    Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n    Math.cos((p1.lat * Math.PI) / 180) *\n      Math.cos((p2.lat * Math.PI) / 180) *\n      Math.sin(dLon / 2) *\n      Math.sin(dLon / 2);\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  return R * c;\n};\n\ntype PixelBounds = {\n  northEast: google.maps.Point;\n  southWest: google.maps.Point;\n};\n\n/**\n * @hidden\n */\nconst latLngBoundsToPixelBounds = (\n  bounds: google.maps.LatLngBounds,\n  projection: google.maps.MapCanvasProjection\n): PixelBounds => {\n  return {\n    northEast: projection.fromLatLngToDivPixel(bounds.getNorthEast()),\n    southWest: projection.fromLatLngToDivPixel(bounds.getSouthWest()),\n  };\n};\n\n/**\n * @hidden\n */\nexport const extendPixelBounds = (\n  { northEast, southWest }: PixelBounds,\n  pixels: number\n): PixelBounds => {\n  northEast.x += pixels;\n  northEast.y -= pixels;\n\n  southWest.x -= pixels;\n  southWest.y += pixels;\n\n  return { northEast, southWest };\n};\n\n/**\n * @hidden\n */\nexport const pixelBoundsToLatLngBounds = (\n  { northEast, southWest }: PixelBounds,\n  projection: google.maps.MapCanvasProjection\n): google.maps.LatLngBounds => {\n  const bounds = new google.maps.LatLngBounds();\n  bounds.extend(projection.fromDivPixelToLatLng(northEast));\n  bounds.extend(projection.fromDivPixelToLatLng(southWest));\n  return bounds;\n};\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Cluster } from \"../cluster\";\nimport { filterMarkersToPaddedViewport } from \"./utils\";\n\nexport interface AlgorithmInput {\n  /**\n   * The map containing the markers and clusters.\n   */\n  map: google.maps.Map;\n  /**\n   * An array of markers to be clustered.\n   *\n   * There are some specific edge cases to be aware of including the following:\n   * * Markers that are not visible.\n   */\n  markers: google.maps.Marker[];\n  /**\n   * The `mapCanvasProjection` enables easy conversion from lat/lng to pixel.\n   *\n   * @see [MapCanvasProjection](https://developers.google.com/maps/documentation/javascript/reference/overlay-view#MapCanvasProjection)\n   */\n  mapCanvasProjection: google.maps.MapCanvasProjection;\n}\n\nexport interface AlgorithmOutput {\n  /**\n   * The clusters returned based upon the {@link AlgorithmInput}.\n   */\n  clusters: Cluster[];\n  /**\n   * A boolean flag indicating that the clusters have not changed.\n   */\n  changed?: boolean;\n}\n\nexport interface Algorithm {\n  /**\n   * Calculates an array of {@link Cluster}.\n   */\n  calculate: ({ markers, map }: AlgorithmInput) => AlgorithmOutput;\n}\n\nexport interface AlgorithmOptions {\n  maxZoom?: number;\n}\n/**\n * @hidden\n */\nexport abstract class AbstractAlgorithm implements Algorithm {\n  protected maxZoom: number;\n\n  constructor({ maxZoom = 16 }: AlgorithmOptions) {\n    this.maxZoom = maxZoom;\n  }\n  /**\n   * Helper function to bypass clustering based upon some map state such as\n   * zoom, number of markers, etc.\n   *\n   * ```typescript\n   *  cluster({markers, map}: AlgorithmInput): Cluster[] {\n   *    if (shouldBypassClustering(map)) {\n   *      return this.noop({markers, map})\n   *    }\n   * }\n   * ```\n   */\n  protected noop({ markers }: AlgorithmInput): Cluster[] {\n    return noop(markers);\n  }\n  /**\n   * Calculates an array of {@link Cluster}. Calculate is separate from\n   * {@link cluster} as it does preprocessing on the markers such as filtering\n   * based upon the viewport as in {@link AbstractViewportAlgorithm}. Caching\n   * and other optimizations can also be done here.\n   */\n  public abstract calculate({ markers, map }: AlgorithmInput): AlgorithmOutput;\n\n  /**\n   * Clusters the markers and called from {@link calculate}.\n   */\n  protected abstract cluster({ markers, map }: AlgorithmInput): Cluster[];\n}\n\n/**\n * @hidden\n */\nexport interface ViewportAlgorithmOptions extends AlgorithmOptions {\n  /**\n   * The number of pixels to extend beyond the viewport bounds when filtering\n   * markers prior to clustering.\n   */\n  viewportPadding?: number;\n}\n\n/**\n * Abstract viewport algorithm proves a class to filter markers by a padded\n * viewport. This is a common optimization.\n *\n * @hidden\n */\nexport abstract class AbstractViewportAlgorithm extends AbstractAlgorithm {\n  protected viewportPadding = 60;\n\n  constructor({ viewportPadding = 60, ...options }: ViewportAlgorithmOptions) {\n    super(options);\n    this.viewportPadding = viewportPadding;\n  }\n  public calculate({\n    markers,\n    map,\n    mapCanvasProjection,\n  }: AlgorithmInput): AlgorithmOutput {\n    if (map.getZoom() >= this.maxZoom) {\n      return {\n        clusters: this.noop({\n          markers,\n          map,\n          mapCanvasProjection,\n        }),\n        changed: false,\n      };\n    }\n\n    return {\n      clusters: this.cluster({\n        markers: filterMarkersToPaddedViewport(\n          map,\n          mapCanvasProjection,\n          markers,\n          this.viewportPadding\n        ),\n        map,\n        mapCanvasProjection,\n      }),\n    };\n  }\n  protected abstract cluster({ markers, map }: AlgorithmInput): Cluster[];\n}\n\n/**\n * @hidden\n */\nexport const noop = (markers: google.maps.Marker[]): Cluster[] => {\n  const clusters = markers.map(\n    (marker) =>\n      new Cluster({\n        position: marker.getPosition(),\n        markers: [marker],\n      })\n  );\n  return clusters;\n};\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { AbstractAlgorithm, AlgorithmInput, AlgorithmOutput } from \"./core\";\nimport SuperCluster, { ClusterFeature } from \"supercluster\";\n\nimport { Cluster } from \"../cluster\";\nimport equal from \"fast-deep-equal\";\n\nexport type SuperClusterOptions = SuperCluster.Options<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  { [name: string]: any },\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  { [name: string]: any }\n>;\n\n/**\n * A very fast JavaScript algorithm for geospatial point clustering using KD trees.\n *\n * @see https://www.npmjs.com/package/supercluster for more information on options.\n */\nexport class SuperClusterAlgorithm extends AbstractAlgorithm {\n  protected superCluster: SuperCluster;\n  protected markers: google.maps.Marker[];\n  protected clusters: Cluster[];\n  protected state: { zoom: number };\n\n  constructor({ maxZoom, radius = 60, ...options }: SuperClusterOptions) {\n    super({ maxZoom });\n\n    this.superCluster = new SuperCluster({\n      maxZoom: this.maxZoom,\n      radius,\n      ...options,\n    });\n\n    this.state = { zoom: null };\n  }\n  public calculate(input: AlgorithmInput): AlgorithmOutput {\n    let changed = false;\n\n    if (!equal(input.markers, this.markers)) {\n      changed = true;\n      // TODO use proxy to avoid copy?\n      this.markers = [...input.markers];\n\n      const points = this.markers.map((marker) => {\n        return {\n          type: \"Feature\" as const,\n          geometry: {\n            type: \"Point\" as const,\n            coordinates: [\n              marker.getPosition().lng(),\n              marker.getPosition().lat(),\n            ],\n          },\n          properties: { marker },\n        };\n      });\n\n      this.superCluster.load(points);\n    }\n\n    const state = { zoom: input.map.getZoom() };\n\n    if (!changed) {\n      if (this.state.zoom > this.maxZoom && state.zoom > this.maxZoom) {\n        // still beyond maxZoom, no change\n      } else {\n        changed = changed || !equal(this.state, state);\n      }\n    }\n\n    this.state = state;\n\n    if (changed) {\n      this.clusters = this.cluster(input);\n    }\n\n    return { clusters: this.clusters, changed };\n  }\n\n  public cluster({ map }: AlgorithmInput): Cluster[] {\n    return this.superCluster\n      .getClusters([-180, -90, 180, 90], Math.round(map.getZoom()))\n      .map(this.transformCluster.bind(this));\n  }\n\n  protected transformCluster({\n    geometry: {\n      coordinates: [lng, lat],\n    },\n    properties,\n  }: ClusterFeature<{ marker: google.maps.Marker }>): Cluster {\n    if (properties.cluster) {\n      return new Cluster({\n        markers: this.superCluster\n          .getLeaves(properties.cluster_id, Infinity)\n          .map((leaf) => leaf.properties.marker),\n        position: new google.maps.LatLng({ lat, lng }),\n      });\n    } else {\n      const marker = properties.marker;\n\n      return new Cluster({\n        markers: [marker],\n        position: marker.getPosition(),\n      });\n    }\n  }\n}\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Cluster } from \"./cluster\";\n\n/**\n * Provides statistics on all clusters in the current render cycle for use in {@link Renderer.render}.\n */\nexport class ClusterStats {\n  public readonly markers: { sum: number };\n  public readonly clusters: {\n    count: number;\n    markers: {\n      mean: number;\n      sum: number;\n      min: number;\n      max: number;\n    };\n  };\n\n  constructor(markers: google.maps.Marker[], clusters: Cluster[]) {\n    this.markers = { sum: markers.length };\n\n    const clusterMarkerCounts = clusters.map((a) => a.count);\n    const clusterMarkerSum = clusterMarkerCounts.reduce((a, b) => a + b, 0);\n\n    this.clusters = {\n      count: clusters.length,\n      markers: {\n        mean: clusterMarkerSum / clusters.length,\n        sum: clusterMarkerSum,\n        min: Math.min(...clusterMarkerCounts),\n        max: Math.max(...clusterMarkerCounts),\n      },\n    };\n  }\n}\n\nexport interface Renderer {\n  /**\n   * Turn a {@link Cluster} into a `google.maps.Marker`.\n   *\n   * Below is a simple example to create a marker with the number of markers in the cluster as a label.\n   *\n   * ```typescript\n   * return new google.maps.Marker({\n   *   position,\n   *   label: String(markers.length),\n   * });\n   * ```\n   */\n  render(cluster: Cluster, stats: ClusterStats): google.maps.Marker;\n}\n\nexport class DefaultRenderer implements Renderer {\n  /**\n   * The default render function for the library used by {@link MarkerClusterer}.\n   *\n   * Currently set to use the following:\n   *\n   * ```typescript\n   * // change color if this cluster has more markers than the mean cluster\n   * const color =\n   *   count > Math.max(10, stats.clusters.markers.mean)\n   *     ? \"#ff0000\"\n   *     : \"#0000ff\";\n   *\n   * // create svg url with fill color\n   * const svg = window.btoa(`\n   * <svg fill=\"${color}\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 240 240\">\n   *   <circle cx=\"120\" cy=\"120\" opacity=\".6\" r=\"70\" />\n   *   <circle cx=\"120\" cy=\"120\" opacity=\".3\" r=\"90\" />\n   *   <circle cx=\"120\" cy=\"120\" opacity=\".2\" r=\"110\" />\n   *   <circle cx=\"120\" cy=\"120\" opacity=\".1\" r=\"130\" />\n   * </svg>`);\n   *\n   * // create marker using svg icon\n   * return new google.maps.Marker({\n   *   position,\n   *   icon: {\n   *     url: `data:image/svg+xml;base64,${svg}`,\n   *     scaledSize: new google.maps.Size(45, 45),\n   *   },\n   *   label: {\n   *     text: String(count),\n   *     color: \"rgba(255,255,255,0.9)\",\n   *     fontSize: \"12px\",\n   *   },\n   *   // adjust zIndex to be above other markers\n   *   zIndex: 1000 + count,\n   * });\n   * ```\n   */\n  public render(\n    { count, position }: Cluster,\n    stats: ClusterStats\n  ): google.maps.Marker {\n    // change color if this cluster has more markers than the mean cluster\n    const color =\n      count > Math.max(10, stats.clusters.markers.mean) ? \"#ff0000\" : \"#0000ff\";\n\n    // create svg url with fill color\n    const svg = window.btoa(`\n  <svg fill=\"${color}\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 240 240\">\n    <circle cx=\"120\" cy=\"120\" opacity=\".6\" r=\"70\" />\n    <circle cx=\"120\" cy=\"120\" opacity=\".3\" r=\"90\" />\n    <circle cx=\"120\" cy=\"120\" opacity=\".2\" r=\"110\" />\n  </svg>`);\n\n    // create marker using svg icon\n    return new google.maps.Marker({\n      position,\n      icon: {\n        url: `data:image/svg+xml;base64,${svg}`,\n        scaledSize: new google.maps.Size(45, 45),\n      },\n      label: {\n        text: String(count),\n        color: \"rgba(255,255,255,0.9)\",\n        fontSize: \"12px\",\n      },\n      title: `Cluster of ${count} markers`,\n      // adjust zIndex to be above other markers\n      zIndex: Number(google.maps.Marker.MAX_ZINDEX) + count,\n    });\n  }\n}\n","/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface OverlayViewSafe extends google.maps.OverlayView {}\n\n/**\n * Extends an object's prototype by another's.\n *\n * @param type1 The Type to be extended.\n * @param type2 The Type to extend with.\n * @ignore\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction extend(type1: any, type2: any): void {\n  /* istanbul ignore next */\n  // eslint-disable-next-line prefer-const\n  for (let property in type2.prototype) {\n    type1.prototype[property] = type2.prototype[property];\n  }\n}\n\n/**\n * @ignore\n */\nexport class OverlayViewSafe {\n  constructor() {\n    // MarkerClusterer implements google.maps.OverlayView interface. We use the\n    // extend function to extend MarkerClusterer with google.maps.OverlayView\n    // because it might not always be available when the code is defined so we\n    // look for it at the last possible moment. If it doesn't exist now then\n    // there is no point going ahead :)\n    extend(OverlayViewSafe, google.maps.OverlayView);\n  }\n}\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Algorithm, SuperClusterAlgorithm } from \"./algorithms\";\nimport { ClusterStats, DefaultRenderer, Renderer } from \"./renderer\";\n\nimport { Cluster } from \"./cluster\";\nimport { OverlayViewSafe } from \"./overlay-view-safe\";\n\nexport type onClusterClickHandler = (\n  event: google.maps.MapMouseEvent,\n  cluster: Cluster,\n  map: google.maps.Map\n) => void;\nexport interface MarkerClustererOptions {\n  markers?: google.maps.Marker[];\n  /**\n   * An algorithm to cluster markers. Default is {@link SuperClusterAlgorithm}. Must\n   * provide a `calculate` method accepting {@link AlgorithmInput} and returning\n   * an array of {@link Cluster}.\n   */\n  algorithm?: Algorithm;\n  map?: google.maps.Map | null;\n  /**\n   * An object that converts a {@link Cluster} into a `google.maps.Marker`.\n   * Default is {@link DefaultRenderer}.\n   */\n  renderer?: Renderer;\n  onClusterClick?: onClusterClickHandler;\n}\n\nexport enum MarkerClustererEvents {\n  CLUSTERING_BEGIN = \"clusteringbegin\",\n  CLUSTERING_END = \"clusteringend\",\n  CLUSTER_CLICK = \"click\",\n}\n\nexport const defaultOnClusterClickHandler: onClusterClickHandler = (\n  _: google.maps.MapMouseEvent,\n  cluster: Cluster,\n  map: google.maps.Map\n): void => {\n  map.fitBounds(cluster.bounds);\n};\n/**\n * MarkerClusterer creates and manages per-zoom-level clusters for large amounts\n * of markers. See {@link MarkerClustererOptions} for more details.\n *\n */\nexport class MarkerClusterer extends OverlayViewSafe {\n  /** @see {@link MarkerClustererOptions.onClusterClick} */\n  public onClusterClick: onClusterClickHandler;\n  /** @see {@link MarkerClustererOptions.algorithm} */\n  protected algorithm: Algorithm;\n  protected clusters: Cluster[];\n  protected markers: google.maps.Marker[];\n  /** @see {@link MarkerClustererOptions.renderer} */\n  protected renderer: Renderer;\n  /** @see {@link MarkerClustererOptions.map} */\n  protected map: google.maps.Map | null;\n  /** @see {@link MarkerClustererOptions.maxZoom} */\n  protected idleListener: google.maps.MapsEventListener;\n\n  constructor({\n    map,\n    markers = [],\n    algorithm = new SuperClusterAlgorithm({}),\n    renderer = new DefaultRenderer(),\n    onClusterClick = defaultOnClusterClickHandler,\n  }: MarkerClustererOptions) {\n    super();\n    this.markers = [...markers];\n    this.clusters = [];\n\n    this.algorithm = algorithm;\n    this.renderer = renderer;\n\n    this.onClusterClick = onClusterClick;\n\n    if (map) {\n      this.setMap(map);\n    }\n  }\n\n  public addMarker(marker: google.maps.Marker, noDraw?: boolean): void {\n    if (this.markers.includes(marker)) {\n      return;\n    }\n\n    this.markers.push(marker);\n    if (!noDraw) {\n      this.render();\n    }\n  }\n\n  public addMarkers(markers: google.maps.Marker[], noDraw?: boolean): void {\n    markers.forEach((marker) => {\n      this.addMarker(marker, true);\n    });\n\n    if (!noDraw) {\n      this.render();\n    }\n  }\n\n  public removeMarker(marker: google.maps.Marker, noDraw?: boolean): boolean {\n    const index = this.markers.indexOf(marker);\n\n    if (index === -1) {\n      // Marker is not in our list of markers, so do nothing:\n      return false;\n    }\n\n    marker.setMap(null);\n    this.markers.splice(index, 1); // Remove the marker from the list of managed markers\n\n    if (!noDraw) {\n      this.render();\n    }\n\n    return true;\n  }\n\n  public removeMarkers(\n    markers: google.maps.Marker[],\n    noDraw?: boolean\n  ): boolean {\n    let removed = false;\n\n    markers.forEach((marker) => {\n      removed = this.removeMarker(marker, true) || removed;\n    });\n\n    if (removed && !noDraw) {\n      this.render();\n    }\n\n    return removed;\n  }\n\n  public clearMarkers(noDraw?: boolean): void {\n    this.markers.length = 0;\n\n    if (!noDraw) {\n      this.render();\n    }\n  }\n\n  /**\n   * Recalculates and draws all the marker clusters.\n   */\n  public render(): void {\n    const map = this.getMap();\n    if (map instanceof google.maps.Map && this.getProjection()) {\n      google.maps.event.trigger(\n        this,\n        MarkerClustererEvents.CLUSTERING_BEGIN,\n        this\n      );\n      const { clusters, changed } = this.algorithm.calculate({\n        markers: this.markers,\n        map,\n        mapCanvasProjection: this.getProjection(),\n      });\n\n      // allow algorithms to return flag on whether the clusters/markers have changed\n      if (changed || changed == undefined) {\n        // reset visibility of markers and clusters\n        this.reset();\n\n        // store new clusters\n        this.clusters = clusters;\n\n        this.renderClusters();\n      }\n      google.maps.event.trigger(\n        this,\n        MarkerClustererEvents.CLUSTERING_END,\n        this\n      );\n    }\n  }\n\n  public onAdd(): void {\n    this.idleListener = this.getMap().addListener(\n      \"idle\",\n      this.render.bind(this)\n    );\n    this.render();\n  }\n\n  public onRemove(): void {\n    google.maps.event.removeListener(this.idleListener);\n    this.reset();\n  }\n\n  protected reset(): void {\n    this.markers.forEach((marker) => marker.setMap(null));\n    this.clusters.forEach((cluster) => cluster.delete());\n    this.clusters = [];\n  }\n\n  protected renderClusters(): void {\n    // generate stats to pass to renderers\n    const stats = new ClusterStats(this.markers, this.clusters);\n    const map = this.getMap() as google.maps.Map;\n\n    this.clusters.forEach((cluster) => {\n      if (cluster.markers.length === 1) {\n        cluster.marker = cluster.markers[0];\n      } else {\n        cluster.marker = this.renderer.render(cluster, stats);\n\n        if (this.onClusterClick) {\n          cluster.marker.addListener(\n            \"click\",\n            /* istanbul ignore next */\n            (event: google.maps.MapMouseEvent) => {\n              google.maps.event.trigger(\n                this,\n                MarkerClustererEvents.CLUSTER_CLICK,\n                cluster\n              );\n              this.onClusterClick(event, cluster, map);\n            }\n          );\n        }\n      }\n\n      cluster.marker.setMap(map);\n    });\n  }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _defineProperty;\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\n","const points = [\n  { id: 1, lat: 50.3864813, lng: 30.4610184 },\n  { id: 2, lat: 50.3893584, lng: 30.4744418 },\n  { id: 3, lat: 50.3766632, lng: 30.4545341 },\n  { id: 4, lat: 50.3871685, lng: 30.4633948 },\n  { id: 5, lat: 50.3839428, lng: 30.4448406 },\n  { id: 6, lat: 50.3950753, lng: 30.5020464 },\n  { id: 7, lat: 50.3932314, lng: 30.4851096 },\n  { id: 8, lat: 50.3932962, lng: 30.4808875 },\n  { id: 9, lat: 50.3850642, lng: 30.4800686 },\n  { id: 10, lat: 50.3852944, lng: 30.4568793 },\n  { id: 11, lat: 50.383335, lng: 30.4582703 },\n];\n\nconst appartments = [\n  {\n    id: 1,\n    title: 'Вільямса, 9',\n    image:\n      'https://images.pexels.com/photos/271624/pexels-photo-271624.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1',\n    description:\n      'Lorem ipsum dolor, sit amet consectetur adipisicing elit. Sint tempore quidem aliquam, vero itaque architecto qui minima hic saepe placeat?',\n  },\n  {\n    id: 2,\n    title: 'Ломоносова, 38',\n    image:\n      'https://images.pexels.com/photos/1643383/pexels-photo-1643383.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1',\n    description:\n      'Lorem ipsum dolor, sit amet consectetur adipisicing elit. Sint tempore quidem aliquam, vero itaque architecto qui minima hic saepe placeat?',\n  },\n  {\n    id: 3,\n    title: 'Касьяна, 20',\n    image:\n      'https://images.pexels.com/photos/667838/pexels-photo-667838.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1',\n    description:\n      'Lorem ipsum dolor, sit amet consectetur adipisicing elit. Sint tempore quidem aliquam, vero itaque architecto qui minima hic saepe placeat?',\n  },\n  {\n    id: 4,\n    title: 'Мейтуса, 10',\n    image:\n      'https://images.pexels.com/photos/245208/pexels-photo-245208.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1',\n    description:\n      'Lorem ipsum dolor, sit amet consectetur adipisicing elit. Sint tempore quidem aliquam, vero itaque architecto qui minima hic saepe placeat?',\n  },\n  {\n    id: 5,\n    title: 'Луценка, 11',\n    image:\n      'https://images.pexels.com/photos/259962/pexels-photo-259962.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1',\n    description:\n      'Lorem ipsum dolor, sit amet consectetur adipisicing elit. Sint tempore quidem aliquam, vero itaque architecto qui minima hic saepe placeat?',\n  },\n  {\n    id: 6,\n    title: 'Васильківська, 11',\n    image:\n      'https://images.pexels.com/photos/439227/pexels-photo-439227.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1',\n    description:\n      'Lorem ipsum dolor, sit amet consectetur adipisicing elit. Sint tempore quidem aliquam, vero itaque architecto qui minima hic saepe placeat?',\n  },\n  {\n    id: 7,\n    title: 'Васильківська, 34',\n    image:\n      'https://images.pexels.com/photos/1669799/pexels-photo-1669799.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1',\n    description:\n      'Lorem ipsum dolor, sit amet consectetur adipisicing elit. Sint tempore quidem aliquam, vero itaque architecto qui minima hic saepe placeat?',\n  },\n  {\n    id: 8,\n    title: 'Максимовича, 4',\n    image:\n      'https://images.pexels.com/photos/1571459/pexels-photo-1571459.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1',\n    description:\n      'Lorem ipsum dolor, sit amet consectetur adipisicing elit. Sint tempore quidem aliquam, vero itaque architecto qui minima hic saepe placeat?',\n  },\n  {\n    id: 9,\n    title: 'Васильківська, 53',\n    image:\n      'https://images.pexels.com/photos/1648771/pexels-photo-1648771.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1',\n    description:\n      'Lorem ipsum dolor, sit amet consectetur adipisicing elit. Sint tempore quidem aliquam, vero itaque architecto qui minima hic saepe placeat?',\n  },\n  {\n    id: 10,\n    title: 'Вільямса, 11',\n    image:\n      'https://images.pexels.com/photos/271743/pexels-photo-271743.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1',\n    description:\n      'Lorem ipsum dolor, sit amet consectetur adipisicing elit. Sint tempore quidem aliquam, vero itaque architecto qui minima hic saepe placeat?',\n  },\n  {\n    id: 11,\n    title: 'Конєва, 10',\n    image:\n      'https://images.pexels.com/photos/265004/pexels-photo-265004.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1',\n    description:\n      'Lorem ipsum dolor, sit amet consectetur adipisicing elit. Sint tempore quidem aliquam, vero itaque architecto qui minima hic saepe placeat?',\n  },\n];\n\nexport { points, appartments };\n","import { points, appartments } from './points';\n\nexport class ModelObjectHandler {\n  getAllPoints = () => {\n    return points;\n  };\n\n  getLastPointId = () => {\n    return points[points.length - 1].id;\n  };\n\n  getAllAppartments = () => {\n    return appartments;\n  };\n\n  getAppartmentById = id => {\n    return appartments[\n      appartments.findIndex(appartment => appartment.id === id)\n    ];\n  };\n\n  getAppartmentsByIdArr = idArr => {\n    return appartments.filter(appartment => idArr.includes(appartment.id));\n  };\n\n  getVisiblePointsId = rectangle =>\n    points.filter(isInBounds(rectangle)).map(getPointId);\n\n  initBuffer = (lastPointId, { lat, lng }) => {\n    this.bufferObj.status = 'PREPAING';\n    this.bufferObj.id = lastPointId + 1;\n    this.bufferObj.lat = lat;\n    this.bufferObj.lng = lng;\n  };\n\n  addAppartmentToBuffer = ({ title, image, description }) => {\n    this.bufferObj.status = 'READY';\n    this.bufferObj.title = title;\n    this.bufferObj.image = image;\n    this.bufferObj.description = description;\n  };\n\n  bufferObj = {\n    status: 'EMPTY',\n    id: null,\n    lat: null,\n    lng: null,\n    title: '',\n    image: '',\n    description: '',\n  };\n}\n\n//STATUS_OF_BUFFER = (EMPTY, PRERAPING, READY);\n\nconst getPointId = point => point.id;\n\nconst isInBounds =\n  ({ south, north, west, east }) =>\n  ({ lat, lng }) =>\n    lng > west && lng < east && lat > south && lat < north;\n","import { MarkerClusterer } from '@googlemaps/markerclusterer';\n\nexport function createMap(container) {\n  const map = new google.maps.Map(container, {\n    zoom: 16,\n    center: { lat: 50.3864813, lng: 30.4610184 },\n    mapTypeControl: true,\n    mapTypeControlOptions: {\n      style: google.maps.MapTypeControlStyle.HORIZONTAL_BAR,\n      position: google.maps.ControlPosition.TOP_CENTER,\n    },\n    zoomControl: true,\n    zoomControlOptions: {\n      position: google.maps.ControlPosition.LEFT_CENTER,\n    },\n    scaleControl: true,\n    streetViewControl: true,\n    streetViewControlOptions: {\n      position: google.maps.ControlPosition.LEFT_TOP,\n    },\n    fullscreenControl: true,\n  });\n\n  const mapObservers = [];\n\n  const addPoints = points => {\n    const markers = points.map(({ id, lat, lng }) => {\n      const label = id.toString();\n\n      const marker = new google.maps.Marker({\n        position: { lat, lng },\n        label,\n      });\n\n      marker.addListener('click', mapsMouseEvent => {\n        console.log('CLICK!!!', marker.label, map.zoom);\n        map.setZoom(18);\n        map.setCenter(marker.position);\n      });\n\n      return marker;\n    });\n\n    new MarkerClusterer({ markers, map });\n  };\n\n  map.addListener('bounds_changed', boundsChanged);\n\n  function boundsChanged() {\n    for (let i = 0; i < mapObservers.length; i++) {\n      if (mapObservers[i].eventName === 'bounds_changed') {\n        mapObservers[i].listener(map.getBounds().toJSON());\n      }\n    }\n  }\n\n  const findNewPoints = request => {\n    return new Promise((resolve, reject) => {\n      var service = new google.maps.places.PlacesService(map);\n\n      service.findPlaceFromQuery(request, function (results, status) {\n        if (status === google.maps.places.PlacesServiceStatus.OK) {\n          createMarker(results[0]);\n          const newPointCoordinates = {\n            lat: results[0].geometry.location.lat(),\n            lng: results[0].geometry.location.lng(),\n          };\n\n          map.setCenter(results[0].geometry.location);\n          resolve(newPointCoordinates);\n        } else {\n          reject(status);\n        }\n      });\n\n      function createMarker(place) {\n        if (!place.geometry || !place.geometry.location) return;\n\n        const marker = new google.maps.Marker({\n          map,\n          position: place.geometry.location,\n        });\n      }\n    });\n  };\n\n  function addEventListener(eventName, listener) {\n    mapObservers.push({ eventName, listener });\n  }\n\n  function removeEventListener(eventName, handler) {}\n\n  return {\n    addPoints,\n    findNewPoints,\n    zoomTo: () => {},\n    addEventListener,\n    removeEventListener,\n  };\n}\n\n//-----------------------------------\n","export class Gallery {\n  itemsGalleryEl = '';\n\n  constructor(root) {\n    this.itemsGalleryEl = document.querySelector(root);\n  }\n\n  renderItemsGallery = appartments => {\n    return appartments\n      .map(appart => {\n        return `\n    <li class=\"item\" data-id=\"${appart.id}\">\n    <img class=\"item--img\" src=\"${appart.image}\" alt=\"\" />\n    <div class=\"item--details\">\n      <h3 class=\"item--title\">${appart.title}</h3>\n      <p class=\"item--description\">${appart.description}</p>\n    </div>\n  </li>\n    `;\n      })\n      .join('');\n  };\n\n  showAppartments = appartments => {\n    this.itemsGalleryEl.innerHTML = this.renderItemsGallery(appartments);\n  };\n\n  hideGallery = () => {\n    this.itemsGalleryEl.classList.add('invisible');\n  };\n\n  openGallery = () => {\n    this.itemsGalleryEl.classList.remove('invisible');\n  };\n}\n","export class Form {\n  rootEl = '';\n  ref = {\n    inputAddress: '',\n    inputImageLink: '',\n    inputDescripton: '',\n    buttonSearch: '',\n    stepAdd: [],\n  };\n\n  constructor(root) {\n    this.rootEl = document.querySelector(root);\n    this.hideForm();\n  }\n\n  renderFormToAddNewAppartment = (onSubmitSearch, onSubmitAdd) => {\n    this.rootEl.innerHTML = `\n<div class=\"form__wrap\">\n  <h3 class=\"form__title\">Додайте новий об'єкт</h3>\n  <form class=\"form__body\">\n    <label class=\"form__label\">\n      <span class=\"form__text\">Адреса</span>\n      <input class=\"form__field\" type=\"text\" name=\"title\" placeholder=\"назва вулиці, № будинку\" />\n    </label>\n\n    <label class=\"form__label\">\n      <span class=\"form__text invisible\" option=\"stepAdd\">Посилання на фото</span>\n      <input class=\"form__field invisible\" type=\"text\" name=\"image\" option=\"stepAdd\" placeholder=\"\" />\n    </label>\n\n    <label class=\"form__label \">\n      <span class=\"form__text invisible\" option=\"stepAdd\">Опис</span>\n      <textarea\n        class=\"form__field form__field--textarea invisible\"\n        name=\"description\"\n        option=\"stepAdd\"\n        placeholder=\" \"\n        cols=\"30\"\n        rows=\"10\"\n      ></textarea>\n    </label>\n    <button class=\"form__button form__button--search\" option='step1'>Знайти адресу</button>\n    <button class=\"form__button form__button--save invisible\" type=\"submit\" option='stepAdd'>Додати</button>\n    <div class='form__error'>\n    <p class='error__text--not-found invisible'>Об'єкт не знайдено. Спробуйте ще</p>\n    <p class='error__text--empty-fields invisible'>Заповніть всі поля</p>\n    </div>\n\n  </form>\n</div>\n`;\n    this.ref.inputAddress = this.rootEl.querySelector('input[name=\"title\"]');\n    this.ref.inputImageLink = this.rootEl.querySelector('input[name=\"image\"]');\n    this.ref.inputDescripton = this.rootEl.querySelector(\n      'input[name=\"description\"]'\n    );\n    this.ref.buttonSearch = this.rootEl.querySelector('.form__button--search');\n    this.ref.stepAdd = this.rootEl.querySelectorAll('[option=\"stepAdd\"]');\n\n    this.ref.inputAddress.addEventListener('focus', () => {\n      this.ref.inputAddress.value = '';\n      this.hideErrorSearch();\n    });\n\n    this.rootEl\n      .querySelector('.form__button--search')\n      .addEventListener('click', event => {\n        event.preventDefault();\n\n        const title = this.ref.inputAddress.value;\n        onSubmitSearch(title);\n      });\n\n    this.rootEl\n      .querySelector('.form__body')\n      .addEventListener('submit', event => {\n        event.preventDefault();\n\n        const title = event.currentTarget.elements['title'].value;\n        const image = event.currentTarget.elements['image'].value;\n        const description = event.currentTarget.elements['description'].value;\n        onSubmitAdd({ title, image, description });\n      });\n  };\n\n  openFormAfterSearch = () => {\n    this.ref.buttonSearch.classList.add('invisible');\n    this.ref.stepAdd.forEach(item => item.classList.remove('invisible'));\n  };\n\n  hideForm = () => {\n    this.rootEl.classList.add('invisible');\n  };\n\n  openForm = () => {\n    this.rootEl.classList.remove('invisible');\n  };\n\n  hideErrorSearch = () => {\n    this.rootEl\n      .querySelector('.error__text--not-found')\n      .classList.add('invisible');\n  };\n\n  showErrorSearch = () => {\n    this.rootEl\n      .querySelector('.error__text--not-found')\n      .classList.remove('invisible');\n  };\n}\n","import { MarkerClusterer } from '@googlemaps/markerclusterer';\nimport { ModelObjectHandler } from './modelObjectsHandler';\nimport * as Form from './formHandler';\nimport { createMap } from './createMap';\nimport { Gallery } from './createGallery';\nimport { Form } from './createForm';\n\nfunction initMap() {\n  const map = new google.maps.Map(document.getElementById('map'), {\n    zoom: 16,\n    center: { lat: 50.3864813, lng: 30.4610184 },\n    mapTypeControl: true,\n    mapTypeControlOptions: {\n      style: google.maps.MapTypeControlStyle.HORIZONTAL_BAR,\n      position: google.maps.ControlPosition.TOP_CENTER,\n    },\n    zoomControl: true,\n    zoomControlOptions: {\n      position: google.maps.ControlPosition.LEFT_CENTER,\n    },\n    scaleControl: true,\n    streetViewControl: true,\n    streetViewControlOptions: {\n      position: google.maps.ControlPosition.LEFT_TOP,\n    },\n    fullscreenControl: true,\n  });\n\n  console.log('log bounds: ', map.getBounds());\n\n  map.addListener('click', mapsMouseEvent => {\n    console.log(mapsMouseEvent.latLng.toJSON());\n  });\n\n  map.addListener('bounds_changed', () => {\n    console.log('get bounds: ', map.getBounds().toJSON());\n    const visibleArr = model.getVisiblePointsId(map.getBounds().toJSON());\n\n    //console.log('visible', visibleArr);\n\n    itemsGalleryEl.innerHTML = Form.renderItemsGallery(\n      model.getAppartmentsByIdArr(visibleArr)\n    );\n  });\n\n  const infoWindow = new google.maps.InfoWindow();\n\n  const markers = locations.map(({ id, lat, lng }) => {\n    const label = id.toString();\n\n    const marker = new google.maps.Marker({\n      position: { lat, lng },\n      label,\n    });\n\n    marker.addListener('click', mapsMouseEvent => {\n      console.log('CLICK!!!', marker.label, map.zoom);\n      map.setZoom(18);\n      map.setCenter(marker.position);\n\n      const appartByClickMarketEl = document.querySelector(\n        `[data-id='${marker.label}']`\n      );\n      console.log(appartByClickMarketEl);\n\n      appartByClickMarketEl.scrollIntoView(true);\n    });\n    return marker;\n  });\n\n  //console.log(markers);\n\n  // Add a marker clusterer to manage the markers.\n  new MarkerClusterer({ markers, map });\n\n  // Find new Point to add ---start\n  const addFormToAddNewAppartment = () => {\n    isGalleryRenderingBlockedWhileSearch = true;\n    console.log('ADD FORM');\n\n    const fields = ['name', 'geometry'];\n\n    const onSubmit = formValues => {\n      console.log(formValues);\n\n      findNewPoints({ fields, query: formValues.title })\n        .then(console.log)\n        .catch(console.log);\n    };\n\n    Form.renderFormToAddNewAppartment(itemsGalleryEl, onSubmit);\n  };\n\n  const findNewPoints = request => {\n    return new Promise((resolve, reject) => {\n      var service = new google.maps.places.PlacesService(map);\n\n      service.findPlaceFromQuery(request, function (results, status) {\n        model.setFindStatus(status);\n        // console.log('after set ', model.getFindStatus());\n\n        if (status === google.maps.places.PlacesServiceStatus.OK) {\n          for (var i = 0; i < results.length; i++) {\n            createMarker(results[i]);\n          }\n\n          map.setCenter(results[0].geometry.location);\n          resolve(status);\n        } else {\n          model.setFindStatus(status);\n          reject(status);\n        }\n      });\n\n      function createMarker(place) {\n        if (!place.geometry || !place.geometry.location) return;\n\n        const marker = new google.maps.Marker({\n          map,\n          position: place.geometry.location,\n        });\n\n        google.maps.event.addListener(marker, 'click', mapsMouseEvent => {\n          console.log(mapsMouseEvent.latLng.toJSON());\n          console.log(place.name);\n          infoWindow.setContent(place.name || '');\n          infoWindow.open(map);\n        });\n      }\n    });\n  };\n}\n\nfunction main() {\n  const model = new ModelObjectHandler();\n  const map = createMap(document.getElementById('map'));\n  const gallery = new Gallery('.item--list');\n  const form = new Form('.form-block');\n\n  const btnAddNewAppartmentEl = document.querySelector('.header--btn');\n  btnAddNewAppartmentEl.addEventListener('click', form.openForm);\n  btnAddNewAppartmentEl.addEventListener('click', gallery.hideGallery);\n\n  map.addPoints(model.getAllPoints());\n\n  function onBoundsChange(bounds) {\n    const visiblePoints = model.getVisiblePointsId(bounds);\n\n    gallery.showAppartments(model.getAppartmentsByIdArr(visiblePoints));\n  }\n\n  //observer\n  map.addEventListener('bounds_changed', onBoundsChange);\n\n  const prepareNewPointAndNewAppartmentForm = newPointCoordinates => {\n    model.initBuffer(model.getLastPointId(), newPointCoordinates);\n    form.openFormAfterSearch();\n  };\n\n  const searchOnMap = title => {\n    const fields = ['name', 'geometry'];\n    map\n      .findNewPoints({ fields, query: title })\n      .then(prepareNewPointAndNewAppartmentForm)\n      .catch(form.showErrorSearch);\n  };\n\n  const prepareNewAppartment = ({ title, image, description }) => {\n    model.addAppartmentToBuffer({ title, image, description });\n    console.log(model.bufferObj);\n  };\n\n  form.renderFormToAddNewAppartment(searchOnMap, prepareNewAppartment);\n}\n\nwindow.main = main;\n//window.initMap = initMap;\n"],"names":["$34dec55abe625cc9$export$2e2bcd8739ae039","ids","coords","nodeSize","left","right","depth","m","$34dec55abe625cc9$var$select","k","inc","n","z","Math","log","s","exp","sd","sqrt","max","floor","min","t","i","j","$34dec55abe625cc9$var$swapItem","$34dec55abe625cc9$var$swap","arr","tmp","$878615e4b096134c$export$2e2bcd8739ae039","minX","minY","maxX","maxY","stack","length","result","x","y","axis","pop","push","nextAxis","$a70968a20ae4342b$export$2e2bcd8739ae039","qx","qy","r","r2","$a70968a20ae4342b$var$sqDist","ax","ay","bx","by","dx","dy","$da9c10bf0d633d8b$exports","equal","a","b","constructor","keys","Array","isArray","RegExp","source","flags","valueOf","Object","prototype","toString","hasOwnProperty","call","key","$91a4b9ada9dcd4fc$var$defaultGetX","p","$91a4b9ada9dcd4fc$var$defaultGetY","$91a4b9ada9dcd4fc$export$2e2bcd8739ae039","range","this","within","points","getX","getY","ArrayType","Float64Array","IndexArrayType","Uint16Array","Uint32Array","$6a3d15a5d50a20dd$var$defaultOptions","minZoom","maxZoom","minPoints","radius","extent","generateId","reduce","map","props","$6a3d15a5d50a20dd$var$fround","fround","Float32Array","$6a3d15a5d50a20dd$export$2e2bcd8739ae039","load","options","console","time","timerId","clusters","geometry","$6a3d15a5d50a20dd$var$createPointCluster","trees","$6a3d15a5d50a20dd$var$getX","$6a3d15a5d50a20dd$var$getY","timeEnd","now","Date","_cluster","getClusters","bbox","zoom","minLng","minLat","maxLng","maxLat","easternHem","westernHem","concat","tree","_limitZoom","$6a3d15a5d50a20dd$var$lngX","$6a3d15a5d50a20dd$var$latY","id","c","numPoints","$6a3d15a5d50a20dd$var$getClusterJSON","index","getChildren","clusterId","originId","_getOriginId","originZoom","_getOriginZoom","errorMsg","Error","origin","pow","children","parentId","getLeaves","limit","offset","leaves","_appendLeaves","getTile","z2","top","bottom","tile","features","_addTileFeatures","getClusterExpansionZoom","expansionZoom","properties","cluster_id","skipped","child","cluster","point_count","isCluster","tags","px","py","$6a3d15a5d50a20dd$var$getClusterProperties","coordinates","f","type","round","undefined","neighborIds","numPointsOrigin","neighborId","wx","wy","clusterProperties","_map","numPoints2","$6a3d15a5d50a20dd$var$createCluster","point","clone","$6a3d15a5d50a20dd$var$extend","original","create","Infinity","$6a3d15a5d50a20dd$var$yLat","count","abbrev","point_count_abbreviated","lng","lat","sin","PI","y2","atan","dest","src","$dde19cd987ee6d6e$export$57ed47926628b770","bounds","markers","_position","extend","marker","getPosition","google","maps","LatLngBounds","position","filter","getVisible","delete","setMap","$dde19cd987ee6d6e$export$1e1bee200f7e743e","noop","$dde19cd987ee6d6e$export$8793edee2d425525","$parcel$interopDefault","input","state","getZoom","changed","superCluster","transformCluster","bind","leaf","LatLng","_a","$dde19cd987ee6d6e$var$__rest","sum","clusterMarkerCounts","clusterMarkerSum","stats","mean","svg","window","btoa","Marker","icon","url","scaledSize","Size","type1","type2","property","$dde19cd987ee6d6e$export$f87b0506a2cf0bc","MarkerClustererEvents1","$dde19cd987ee6d6e$export$b434dc9855552644","_","fitBounds","$dde19cd987ee6d6e$export$58bd9bb9fcf3dd4f","$dde19cd987ee6d6e$var$OverlayViewSafe","noDraw","includes","render","forEach","addMarker","indexOf","splice","removed","removeMarker","getMap","Map","getProjection","event","trigger","CLUSTERING_BEGIN","algorithm","calculate","mapCanvasProjection","reset","renderClusters","CLUSTERING_END","onAdd","removeListener","idleListener","$dde19cd987ee6d6e$export$2deda6e6beba3286","renderer","onClusterClick","addListener","CLUSTER_CLICK","defineProperty","$da4b248c00322402$exports","value","default","obj","enumerable","configurable","writable","$b11092b003750ebb$export$9f048bf86ee2e9d2","$b11092b003750ebb$export$2f533e9e2cb0c822","title","image","description","$cdbab5c228e4456d$export$510885540657d15b","findIndex","appartment","idArr","rectangle","$cdbab5c228e4456d$var$isInBounds","$cdbab5c228e4456d$var$getPointId","lastPointId","bufferObj","status","south","north","west","east","$786b15bc02cd6cc2$export$d49c9aa30b771d59","container","center","mapTypeControl","mapTypeControlOptions","style","MapTypeControlStyle","HORIZONTAL_BAR","ControlPosition","TOP_CENTER","zoomControl","zoomControlOptions","LEFT_CENTER","scaleControl","streetViewControl","streetViewControlOptions","LEFT_TOP","fullscreenControl","mapObservers","eventName","listener","getBounds","toJSON","label","mapsMouseEvent","setZoom","setCenter","request","Promise","resolve","reject","places","PlacesService","findPlaceFromQuery","results","PlacesServiceStatus","OK","place","location","createMarker","newPointCoordinates","zoomTo","handler","$84c4c517af77e8fa$export$ace63239d21d36e","root","appartments","appart","join","itemsGalleryEl","innerHTML","renderItemsGallery","classList","add","remove","document","querySelector","$6704978bad493937$export$a7fed597f4b8afd8","inputAddress","inputImageLink","inputDescripton","buttonSearch","stepAdd","onSubmitSearch","onSubmitAdd","rootEl","ref","querySelectorAll","addEventListener","hideErrorSearch","preventDefault","currentTarget","elements","item","hideForm","main","model","getElementById","gallery","form","btnAddNewAppartmentEl","openForm","hideGallery","addPoints","getAllPoints","visiblePoints","getVisiblePointsId","showAppartments","getAppartmentsByIdArr","prepareNewPointAndNewAppartmentForm","initBuffer","getLastPointId","openFormAfterSearch","renderFormToAddNewAppartment","findNewPoints","query","then","catch","showErrorSearch","addAppartmentToBuffer"],"version":3,"file":"index.cf0203c7.js.map"}