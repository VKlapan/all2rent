{"mappings":"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","sources":["node_modules/@swc/helpers/lib/_define_property.js","src/js/points.js","src/js/modelObjectsHandler.js","node_modules/kdbush/src/sort.js","node_modules/kdbush/src/range.js","node_modules/kdbush/src/within.js","node_modules/fast-deep-equal/index.js","node_modules/kdbush/src/index.js","node_modules/supercluster/index.js","node_modules/@googlemaps/markerclusterer/src/cluster.ts","node_modules/@googlemaps/markerclusterer/src/algorithms/utils.ts","node_modules/@googlemaps/markerclusterer/src/algorithms/core.ts","node_modules/@googlemaps/markerclusterer/src/algorithms/supercluster.ts","node_modules/@googlemaps/markerclusterer/src/renderer.ts","node_modules/@googlemaps/markerclusterer/src/overlay-view-safe.ts","node_modules/@googlemaps/markerclusterer/src/markerclusterer.ts","src/js/createMap.js","src/js/createGallery.js","src/js/createForm.js","src/js/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _defineProperty;\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\n","const points = [\n  { id: 1, lat: 50.3864813, lng: 30.4610184 },\n  { id: 2, lat: 50.3893584, lng: 30.4744418 },\n  { id: 3, lat: 50.3766632, lng: 30.4545341 },\n  { id: 4, lat: 50.3871685, lng: 30.4633948 },\n  { id: 5, lat: 50.3839428, lng: 30.4448406 },\n  { id: 6, lat: 50.3950753, lng: 30.5020464 },\n  { id: 7, lat: 50.3932314, lng: 30.4851096 },\n  { id: 8, lat: 50.3932962, lng: 30.4808875 },\n  { id: 9, lat: 50.3850642, lng: 30.4800686 },\n  { id: 10, lat: 50.3852944, lng: 30.4568793 },\n  { id: 11, lat: 50.383335, lng: 30.4582703 },\n];\n\nconst appartments = [\n  {\n    id: 1,\n    title: 'Вільямса, 9',\n    image:\n      'https://images.pexels.com/photos/271624/pexels-photo-271624.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1',\n    description:\n      'Lorem ipsum dolor, sit amet consectetur adipisicing elit. Sint tempore quidem aliquam, vero itaque architecto qui minima hic saepe placeat?',\n  },\n  {\n    id: 2,\n    title: 'Ломоносова, 38',\n    image:\n      'https://images.pexels.com/photos/1643383/pexels-photo-1643383.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1',\n    description:\n      'Lorem ipsum dolor, sit amet consectetur adipisicing elit. Sint tempore quidem aliquam, vero itaque architecto qui minima hic saepe placeat?',\n  },\n  {\n    id: 3,\n    title: 'Касьяна, 20',\n    image:\n      'https://images.pexels.com/photos/667838/pexels-photo-667838.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1',\n    description:\n      'Lorem ipsum dolor, sit amet consectetur adipisicing elit. Sint tempore quidem aliquam, vero itaque architecto qui minima hic saepe placeat?',\n  },\n  {\n    id: 4,\n    title: 'Мейтуса, 10',\n    image:\n      'https://images.pexels.com/photos/245208/pexels-photo-245208.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1',\n    description:\n      'Lorem ipsum dolor, sit amet consectetur adipisicing elit. Sint tempore quidem aliquam, vero itaque architecto qui minima hic saepe placeat?',\n  },\n  {\n    id: 5,\n    title: 'Луценка, 11',\n    image:\n      'https://images.pexels.com/photos/259962/pexels-photo-259962.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1',\n    description:\n      'Lorem ipsum dolor, sit amet consectetur adipisicing elit. Sint tempore quidem aliquam, vero itaque architecto qui minima hic saepe placeat?',\n  },\n  {\n    id: 6,\n    title: 'Васильківська, 11',\n    image:\n      'https://images.pexels.com/photos/439227/pexels-photo-439227.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1',\n    description:\n      'Lorem ipsum dolor, sit amet consectetur adipisicing elit. Sint tempore quidem aliquam, vero itaque architecto qui minima hic saepe placeat?',\n  },\n  {\n    id: 7,\n    title: 'Васильківська, 34',\n    image:\n      'https://images.pexels.com/photos/1669799/pexels-photo-1669799.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1',\n    description:\n      'Lorem ipsum dolor, sit amet consectetur adipisicing elit. Sint tempore quidem aliquam, vero itaque architecto qui minima hic saepe placeat?',\n  },\n  {\n    id: 8,\n    title: 'Максимовича, 4',\n    image:\n      'https://images.pexels.com/photos/1571459/pexels-photo-1571459.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1',\n    description:\n      'Lorem ipsum dolor, sit amet consectetur adipisicing elit. Sint tempore quidem aliquam, vero itaque architecto qui minima hic saepe placeat?',\n  },\n  {\n    id: 9,\n    title: 'Васильківська, 53',\n    image:\n      'https://images.pexels.com/photos/1648771/pexels-photo-1648771.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1',\n    description:\n      'Lorem ipsum dolor, sit amet consectetur adipisicing elit. Sint tempore quidem aliquam, vero itaque architecto qui minima hic saepe placeat?',\n  },\n  {\n    id: 10,\n    title: 'Вільямса, 11',\n    image:\n      'https://images.pexels.com/photos/271743/pexels-photo-271743.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1',\n    description:\n      'Lorem ipsum dolor, sit amet consectetur adipisicing elit. Sint tempore quidem aliquam, vero itaque architecto qui minima hic saepe placeat?',\n  },\n  {\n    id: 11,\n    title: 'Конєва, 10',\n    image:\n      'https://images.pexels.com/photos/265004/pexels-photo-265004.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1',\n    description:\n      'Lorem ipsum dolor, sit amet consectetur adipisicing elit. Sint tempore quidem aliquam, vero itaque architecto qui minima hic saepe placeat?',\n  },\n];\n\nexport { points, appartments };\n","import { points, appartments } from './points';\n\nexport class ModelObjectHandler {\n  initModel = () => {\n    if (JSON.parse(localStorage.getItem('points')) === null) {\n      localStorage.setItem('points', JSON.stringify(points));\n    }\n\n    if (JSON.parse(localStorage.getItem('appartments')) === null) {\n      localStorage.setItem('appartments', JSON.stringify(appartments));\n    }\n  };\n\n  getAllPoints = () => {\n    return JSON.parse(localStorage.getItem('points'));\n  };\n\n  getLastPointId = () => {\n    const pnts = JSON.parse(localStorage.getItem('points'));\n    return pnts[pnts.length - 1].id;\n  };\n\n  getAllAppartments = () => {\n    return JSON.parse(localStorage.getItem('appartments'));\n  };\n\n  getAppartmentById = id => {\n    const apparts = JSON.parse(localStorage.getItem('appartments'));\n    return [apparts[apparts.findIndex(appartment => appartment.id === id)]];\n  };\n\n  getAppartmentsByIdArr = idArr => {\n    return JSON.parse(localStorage.getItem('appartments')).filter(appartment =>\n      idArr.includes(appartment.id)\n    );\n  };\n\n  getVisiblePointsId = rectangle =>\n    JSON.parse(localStorage.getItem('points'))\n      .filter(isInBounds(rectangle))\n      .map(getPointId);\n\n  initBuffer = (lastPointId, { lat, lng }) => {\n    this.bufferObj.status = 'PREPAING';\n    this.bufferObj.id = lastPointId + 1;\n    this.bufferObj.lat = lat;\n    this.bufferObj.lng = lng;\n  };\n\n  addAppartmentToBuffer = ({ title, image, description }) => {\n    this.bufferObj.status = 'READY';\n    this.bufferObj.title = title;\n    this.bufferObj.image = image;\n    this.bufferObj.description = description;\n  };\n\n  addNewAppartment = ({ id, lat, lng, title, image, description }) => {\n    const pnts = JSON.parse(localStorage.getItem('points'));\n    const apparts = JSON.parse(localStorage.getItem('appartments'));\n\n    pnts.push({ id, lat, lng });\n    apparts.push({ id, title, image, description });\n\n    localStorage.setItem('points', JSON.stringify(pnts));\n    localStorage.setItem('appartments', JSON.stringify(apparts));\n  };\n\n  bufferObj = {\n    status: 'EMPTY',\n    id: null,\n    lat: null,\n    lng: null,\n    title: '',\n    image: '',\n    description: '',\n  };\n}\n\n//STATUS_OF_BUFFER = (EMPTY, PRERAPING, READY);\n\nconst getPointId = point => point.id;\n\nconst isInBounds =\n  ({ south, north, west, east }) =>\n  ({ lat, lng }) =>\n    lng > west && lng < east && lat > south && lat < north;\n","\nexport default function sortKD(ids, coords, nodeSize, left, right, depth) {\n    if (right - left <= nodeSize) return;\n\n    const m = (left + right) >> 1;\n\n    select(ids, coords, m, left, right, depth % 2);\n\n    sortKD(ids, coords, nodeSize, left, m - 1, depth + 1);\n    sortKD(ids, coords, nodeSize, m + 1, right, depth + 1);\n}\n\nfunction select(ids, coords, k, left, right, inc) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            const n = right - left + 1;\n            const m = k - left + 1;\n            const z = Math.log(n);\n            const s = 0.5 * Math.exp(2 * z / 3);\n            const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            select(ids, coords, k, newLeft, newRight, inc);\n        }\n\n        const t = coords[2 * k + inc];\n        let i = left;\n        let j = right;\n\n        swapItem(ids, coords, left, k);\n        if (coords[2 * right + inc] > t) swapItem(ids, coords, left, right);\n\n        while (i < j) {\n            swapItem(ids, coords, i, j);\n            i++;\n            j--;\n            while (coords[2 * i + inc] < t) i++;\n            while (coords[2 * j + inc] > t) j--;\n        }\n\n        if (coords[2 * left + inc] === t) swapItem(ids, coords, left, j);\n        else {\n            j++;\n            swapItem(ids, coords, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swapItem(ids, coords, i, j) {\n    swap(ids, i, j);\n    swap(coords, 2 * i, 2 * j);\n    swap(coords, 2 * i + 1, 2 * j + 1);\n}\n\nfunction swap(arr, i, j) {\n    const tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n","\nexport default function range(ids, coords, minX, minY, maxX, maxY, nodeSize) {\n    const stack = [0, ids.length - 1, 0];\n    const result = [];\n    let x, y;\n\n    while (stack.length) {\n        const axis = stack.pop();\n        const right = stack.pop();\n        const left = stack.pop();\n\n        if (right - left <= nodeSize) {\n            for (let i = left; i <= right; i++) {\n                x = coords[2 * i];\n                y = coords[2 * i + 1];\n                if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[i]);\n            }\n            continue;\n        }\n\n        const m = Math.floor((left + right) / 2);\n\n        x = coords[2 * m];\n        y = coords[2 * m + 1];\n\n        if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[m]);\n\n        const nextAxis = (axis + 1) % 2;\n\n        if (axis === 0 ? minX <= x : minY <= y) {\n            stack.push(left);\n            stack.push(m - 1);\n            stack.push(nextAxis);\n        }\n        if (axis === 0 ? maxX >= x : maxY >= y) {\n            stack.push(m + 1);\n            stack.push(right);\n            stack.push(nextAxis);\n        }\n    }\n\n    return result;\n}\n","\nexport default function within(ids, coords, qx, qy, r, nodeSize) {\n    const stack = [0, ids.length - 1, 0];\n    const result = [];\n    const r2 = r * r;\n\n    while (stack.length) {\n        const axis = stack.pop();\n        const right = stack.pop();\n        const left = stack.pop();\n\n        if (right - left <= nodeSize) {\n            for (let i = left; i <= right; i++) {\n                if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) result.push(ids[i]);\n            }\n            continue;\n        }\n\n        const m = Math.floor((left + right) / 2);\n\n        const x = coords[2 * m];\n        const y = coords[2 * m + 1];\n\n        if (sqDist(x, y, qx, qy) <= r2) result.push(ids[m]);\n\n        const nextAxis = (axis + 1) % 2;\n\n        if (axis === 0 ? qx - r <= x : qy - r <= y) {\n            stack.push(left);\n            stack.push(m - 1);\n            stack.push(nextAxis);\n        }\n        if (axis === 0 ? qx + r >= x : qy + r >= y) {\n            stack.push(m + 1);\n            stack.push(right);\n            stack.push(nextAxis);\n        }\n    }\n\n    return result;\n}\n\nfunction sqDist(ax, ay, bx, by) {\n    const dx = ax - bx;\n    const dy = ay - by;\n    return dx * dx + dy * dy;\n}\n","'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n","\nimport sort from './sort';\nimport range from './range';\nimport within from './within';\n\nconst defaultGetX = p => p[0];\nconst defaultGetY = p => p[1];\n\nexport default class KDBush {\n    constructor(points, getX = defaultGetX, getY = defaultGetY, nodeSize = 64, ArrayType = Float64Array) {\n        this.nodeSize = nodeSize;\n        this.points = points;\n\n        const IndexArrayType = points.length < 65536 ? Uint16Array : Uint32Array;\n\n        const ids = this.ids = new IndexArrayType(points.length);\n        const coords = this.coords = new ArrayType(points.length * 2);\n\n        for (let i = 0; i < points.length; i++) {\n            ids[i] = i;\n            coords[2 * i] = getX(points[i]);\n            coords[2 * i + 1] = getY(points[i]);\n        }\n\n        sort(ids, coords, nodeSize, 0, ids.length - 1, 0);\n    }\n\n    range(minX, minY, maxX, maxY) {\n        return range(this.ids, this.coords, minX, minY, maxX, maxY, this.nodeSize);\n    }\n\n    within(x, y, r) {\n        return within(this.ids, this.coords, x, y, r, this.nodeSize);\n    }\n}\n","\nimport KDBush from 'kdbush';\n\nconst defaultOptions = {\n    minZoom: 0,   // min zoom to generate clusters on\n    maxZoom: 16,  // max zoom level to cluster the points on\n    minPoints: 2, // minimum points to form a cluster\n    radius: 40,   // cluster radius in pixels\n    extent: 512,  // tile extent (radius is calculated relative to it)\n    nodeSize: 64, // size of the KD-tree leaf node, affects performance\n    log: false,   // whether to log timing info\n\n    // whether to generate numeric ids for input features (in vector tiles)\n    generateId: false,\n\n    // a reduce function for calculating custom cluster properties\n    reduce: null, // (accumulated, props) => { accumulated.sum += props.sum; }\n\n    // properties to use for individual points when running the reducer\n    map: props => props // props => ({sum: props.my_value})\n};\n\nconst fround = Math.fround || (tmp => ((x) => { tmp[0] = +x; return tmp[0]; }))(new Float32Array(1));\n\nexport default class Supercluster {\n    constructor(options) {\n        this.options = extend(Object.create(defaultOptions), options);\n        this.trees = new Array(this.options.maxZoom + 1);\n    }\n\n    load(points) {\n        const {log, minZoom, maxZoom, nodeSize} = this.options;\n\n        if (log) console.time('total time');\n\n        const timerId = `prepare ${  points.length  } points`;\n        if (log) console.time(timerId);\n\n        this.points = points;\n\n        // generate a cluster object for each point and index input points into a KD-tree\n        let clusters = [];\n        for (let i = 0; i < points.length; i++) {\n            if (!points[i].geometry) continue;\n            clusters.push(createPointCluster(points[i], i));\n        }\n        this.trees[maxZoom + 1] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n        if (log) console.timeEnd(timerId);\n\n        // cluster points on max zoom, then cluster the results on previous zoom, etc.;\n        // results in a cluster hierarchy across zoom levels\n        for (let z = maxZoom; z >= minZoom; z--) {\n            const now = +Date.now();\n\n            // create a new set of clusters for the zoom and index them with a KD-tree\n            clusters = this._cluster(clusters, z);\n            this.trees[z] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n            if (log) console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now);\n        }\n\n        if (log) console.timeEnd('total time');\n\n        return this;\n    }\n\n    getClusters(bbox, zoom) {\n        let minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\n        const minLat = Math.max(-90, Math.min(90, bbox[1]));\n        let maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\n        const maxLat = Math.max(-90, Math.min(90, bbox[3]));\n\n        if (bbox[2] - bbox[0] >= 360) {\n            minLng = -180;\n            maxLng = 180;\n        } else if (minLng > maxLng) {\n            const easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\n            const westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\n            return easternHem.concat(westernHem);\n        }\n\n        const tree = this.trees[this._limitZoom(zoom)];\n        const ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\n        const clusters = [];\n        for (const id of ids) {\n            const c = tree.points[id];\n            clusters.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n        }\n        return clusters;\n    }\n\n    getChildren(clusterId) {\n        const originId = this._getOriginId(clusterId);\n        const originZoom = this._getOriginZoom(clusterId);\n        const errorMsg = 'No cluster with the specified id.';\n\n        const index = this.trees[originZoom];\n        if (!index) throw new Error(errorMsg);\n\n        const origin = index.points[originId];\n        if (!origin) throw new Error(errorMsg);\n\n        const r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\n        const ids = index.within(origin.x, origin.y, r);\n        const children = [];\n        for (const id of ids) {\n            const c = index.points[id];\n            if (c.parentId === clusterId) {\n                children.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n            }\n        }\n\n        if (children.length === 0) throw new Error(errorMsg);\n\n        return children;\n    }\n\n    getLeaves(clusterId, limit, offset) {\n        limit = limit || 10;\n        offset = offset || 0;\n\n        const leaves = [];\n        this._appendLeaves(leaves, clusterId, limit, offset, 0);\n\n        return leaves;\n    }\n\n    getTile(z, x, y) {\n        const tree = this.trees[this._limitZoom(z)];\n        const z2 = Math.pow(2, z);\n        const {extent, radius} = this.options;\n        const p = radius / extent;\n        const top = (y - p) / z2;\n        const bottom = (y + 1 + p) / z2;\n\n        const tile = {\n            features: []\n        };\n\n        this._addTileFeatures(\n            tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom),\n            tree.points, x, y, z2, tile);\n\n        if (x === 0) {\n            this._addTileFeatures(\n                tree.range(1 - p / z2, top, 1, bottom),\n                tree.points, z2, y, z2, tile);\n        }\n        if (x === z2 - 1) {\n            this._addTileFeatures(\n                tree.range(0, top, p / z2, bottom),\n                tree.points, -1, y, z2, tile);\n        }\n\n        return tile.features.length ? tile : null;\n    }\n\n    getClusterExpansionZoom(clusterId) {\n        let expansionZoom = this._getOriginZoom(clusterId) - 1;\n        while (expansionZoom <= this.options.maxZoom) {\n            const children = this.getChildren(clusterId);\n            expansionZoom++;\n            if (children.length !== 1) break;\n            clusterId = children[0].properties.cluster_id;\n        }\n        return expansionZoom;\n    }\n\n    _appendLeaves(result, clusterId, limit, offset, skipped) {\n        const children = this.getChildren(clusterId);\n\n        for (const child of children) {\n            const props = child.properties;\n\n            if (props && props.cluster) {\n                if (skipped + props.point_count <= offset) {\n                    // skip the whole cluster\n                    skipped += props.point_count;\n                } else {\n                    // enter the cluster\n                    skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);\n                    // exit the cluster\n                }\n            } else if (skipped < offset) {\n                // skip a single point\n                skipped++;\n            } else {\n                // add a single point\n                result.push(child);\n            }\n            if (result.length === limit) break;\n        }\n\n        return skipped;\n    }\n\n    _addTileFeatures(ids, points, x, y, z2, tile) {\n        for (const i of ids) {\n            const c = points[i];\n            const isCluster = c.numPoints;\n\n            let tags, px, py;\n            if (isCluster) {\n                tags = getClusterProperties(c);\n                px = c.x;\n                py = c.y;\n            } else {\n                const p = this.points[c.index];\n                tags = p.properties;\n                px = lngX(p.geometry.coordinates[0]);\n                py = latY(p.geometry.coordinates[1]);\n            }\n\n            const f = {\n                type: 1,\n                geometry: [[\n                    Math.round(this.options.extent * (px * z2 - x)),\n                    Math.round(this.options.extent * (py * z2 - y))\n                ]],\n                tags\n            };\n\n            // assign id\n            let id;\n            if (isCluster) {\n                id = c.id;\n            } else if (this.options.generateId) {\n                // optionally generate id\n                id = c.index;\n            } else if (this.points[c.index].id) {\n                // keep id if already assigned\n                id = this.points[c.index].id;\n            }\n\n            if (id !== undefined) f.id = id;\n\n            tile.features.push(f);\n        }\n    }\n\n    _limitZoom(z) {\n        return Math.max(this.options.minZoom, Math.min(Math.floor(+z), this.options.maxZoom + 1));\n    }\n\n    _cluster(points, zoom) {\n        const clusters = [];\n        const {radius, extent, reduce, minPoints} = this.options;\n        const r = radius / (extent * Math.pow(2, zoom));\n\n        // loop through each point\n        for (let i = 0; i < points.length; i++) {\n            const p = points[i];\n            // if we've already visited the point at this zoom level, skip it\n            if (p.zoom <= zoom) continue;\n            p.zoom = zoom;\n\n            // find all nearby points\n            const tree = this.trees[zoom + 1];\n            const neighborIds = tree.within(p.x, p.y, r);\n\n            const numPointsOrigin = p.numPoints || 1;\n            let numPoints = numPointsOrigin;\n\n            // count the number of points in a potential cluster\n            for (const neighborId of neighborIds) {\n                const b = tree.points[neighborId];\n                // filter out neighbors that are already processed\n                if (b.zoom > zoom) numPoints += b.numPoints || 1;\n            }\n\n            // if there were neighbors to merge, and there are enough points to form a cluster\n            if (numPoints > numPointsOrigin && numPoints >= minPoints) {\n                let wx = p.x * numPointsOrigin;\n                let wy = p.y * numPointsOrigin;\n\n                let clusterProperties = reduce && numPointsOrigin > 1 ? this._map(p, true) : null;\n\n                // encode both zoom and point index on which the cluster originated -- offset by total length of features\n                const id = (i << 5) + (zoom + 1) + this.points.length;\n\n                for (const neighborId of neighborIds) {\n                    const b = tree.points[neighborId];\n\n                    if (b.zoom <= zoom) continue;\n                    b.zoom = zoom; // save the zoom (so it doesn't get processed twice)\n\n                    const numPoints2 = b.numPoints || 1;\n                    wx += b.x * numPoints2; // accumulate coordinates for calculating weighted center\n                    wy += b.y * numPoints2;\n\n                    b.parentId = id;\n\n                    if (reduce) {\n                        if (!clusterProperties) clusterProperties = this._map(p, true);\n                        reduce(clusterProperties, this._map(b));\n                    }\n                }\n\n                p.parentId = id;\n                clusters.push(createCluster(wx / numPoints, wy / numPoints, id, numPoints, clusterProperties));\n\n            } else { // left points as unclustered\n                clusters.push(p);\n\n                if (numPoints > 1) {\n                    for (const neighborId of neighborIds) {\n                        const b = tree.points[neighborId];\n                        if (b.zoom <= zoom) continue;\n                        b.zoom = zoom;\n                        clusters.push(b);\n                    }\n                }\n            }\n        }\n\n        return clusters;\n    }\n\n    // get index of the point from which the cluster originated\n    _getOriginId(clusterId) {\n        return (clusterId - this.points.length) >> 5;\n    }\n\n    // get zoom of the point from which the cluster originated\n    _getOriginZoom(clusterId) {\n        return (clusterId - this.points.length) % 32;\n    }\n\n    _map(point, clone) {\n        if (point.numPoints) {\n            return clone ? extend({}, point.properties) : point.properties;\n        }\n        const original = this.points[point.index].properties;\n        const result = this.options.map(original);\n        return clone && result === original ? extend({}, result) : result;\n    }\n}\n\nfunction createCluster(x, y, id, numPoints, properties) {\n    return {\n        x: fround(x), // weighted cluster center; round for consistency with Float32Array index\n        y: fround(y),\n        zoom: Infinity, // the last zoom the cluster was processed at\n        id, // encodes index of the first child of the cluster and its zoom level\n        parentId: -1, // parent cluster id\n        numPoints,\n        properties\n    };\n}\n\nfunction createPointCluster(p, id) {\n    const [x, y] = p.geometry.coordinates;\n    return {\n        x: fround(lngX(x)), // projected point coordinates\n        y: fround(latY(y)),\n        zoom: Infinity, // the last zoom the point was processed at\n        index: id, // index of the source feature in the original input array,\n        parentId: -1 // parent cluster id\n    };\n}\n\nfunction getClusterJSON(cluster) {\n    return {\n        type: 'Feature',\n        id: cluster.id,\n        properties: getClusterProperties(cluster),\n        geometry: {\n            type: 'Point',\n            coordinates: [xLng(cluster.x), yLat(cluster.y)]\n        }\n    };\n}\n\nfunction getClusterProperties(cluster) {\n    const count = cluster.numPoints;\n    const abbrev =\n        count >= 10000 ? `${Math.round(count / 1000)  }k` :\n        count >= 1000 ? `${Math.round(count / 100) / 10  }k` : count;\n    return extend(extend({}, cluster.properties), {\n        cluster: true,\n        cluster_id: cluster.id,\n        point_count: count,\n        point_count_abbreviated: abbrev\n    });\n}\n\n// longitude/latitude to spherical mercator in [0..1] range\nfunction lngX(lng) {\n    return lng / 360 + 0.5;\n}\nfunction latY(lat) {\n    const sin = Math.sin(lat * Math.PI / 180);\n    const y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\n    return y < 0 ? 0 : y > 1 ? 1 : y;\n}\n\n// spherical mercator to longitude/latitude\nfunction xLng(x) {\n    return (x - 0.5) * 360;\n}\nfunction yLat(y) {\n    const y2 = (180 - y * 360) * Math.PI / 180;\n    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\n}\n\nfunction extend(dest, src) {\n    for (const id in src) dest[id] = src[id];\n    return dest;\n}\n\nfunction getX(p) {\n    return p.x;\n}\nfunction getY(p) {\n    return p.y;\n}\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport interface ClusterOptions {\n  position?: google.maps.LatLng | google.maps.LatLngLiteral;\n  markers?: google.maps.Marker[];\n}\n\nexport class Cluster {\n  public marker: google.maps.Marker;\n  public readonly markers?: google.maps.Marker[];\n  protected _position: google.maps.LatLng;\n\n  constructor({ markers, position }: ClusterOptions) {\n    this.markers = markers;\n\n    if (position) {\n      if (position instanceof google.maps.LatLng) {\n        this._position = position;\n      } else {\n        this._position = new google.maps.LatLng(position);\n      }\n    }\n  }\n\n  public get bounds(): google.maps.LatLngBounds | undefined {\n    if (this.markers.length === 0 && !this._position) {\n      return undefined;\n    }\n\n    return this.markers.reduce((bounds, marker) => {\n      return bounds.extend(marker.getPosition());\n    }, new google.maps.LatLngBounds(this._position, this._position));\n  }\n\n  public get position(): google.maps.LatLng {\n    return this._position || this.bounds.getCenter();\n  }\n\n  /**\n   * Get the count of **visible** markers.\n   */\n  public get count(): number {\n    return this.markers.filter((m: google.maps.Marker) => m.getVisible())\n      .length;\n  }\n\n  /**\n   * Add a marker to the cluster.\n   */\n  public push(marker: google.maps.Marker): void {\n    this.markers.push(marker);\n  }\n\n  /**\n   * Cleanup references and remove marker from map.\n   */\n  public delete(): void {\n    if (this.marker) {\n      this.marker.setMap(null);\n      delete this.marker;\n    }\n    this.markers.length = 0;\n  }\n}\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport const filterMarkersToPaddedViewport = (\n  map: google.maps.Map,\n  mapCanvasProjection: google.maps.MapCanvasProjection,\n  markers: google.maps.Marker[],\n  viewportPadding: number\n): google.maps.Marker[] => {\n  const extendedMapBounds = extendBoundsToPaddedViewport(\n    map.getBounds(),\n    mapCanvasProjection,\n    viewportPadding\n  );\n  return markers.filter((marker) =>\n    extendedMapBounds.contains(marker.getPosition())\n  );\n};\n\n/**\n * Extends a bounds by a number of pixels in each direction.\n */\nexport const extendBoundsToPaddedViewport = (\n  bounds: google.maps.LatLngBounds,\n  projection: google.maps.MapCanvasProjection,\n  pixels: number\n): google.maps.LatLngBounds => {\n  const { northEast, southWest } = latLngBoundsToPixelBounds(\n    bounds,\n    projection\n  );\n  const extendedPixelBounds = extendPixelBounds(\n    { northEast, southWest },\n    pixels\n  );\n  return pixelBoundsToLatLngBounds(extendedPixelBounds, projection);\n};\n\n/**\n * @hidden\n */\nexport const distanceBetweenPoints = (\n  p1: google.maps.LatLngLiteral,\n  p2: google.maps.LatLngLiteral\n): number => {\n  const R = 6371; // Radius of the Earth in km\n  const dLat = ((p2.lat - p1.lat) * Math.PI) / 180;\n  const dLon = ((p2.lng - p1.lng) * Math.PI) / 180;\n  const a =\n    Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n    Math.cos((p1.lat * Math.PI) / 180) *\n      Math.cos((p2.lat * Math.PI) / 180) *\n      Math.sin(dLon / 2) *\n      Math.sin(dLon / 2);\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  return R * c;\n};\n\ntype PixelBounds = {\n  northEast: google.maps.Point;\n  southWest: google.maps.Point;\n};\n\n/**\n * @hidden\n */\nconst latLngBoundsToPixelBounds = (\n  bounds: google.maps.LatLngBounds,\n  projection: google.maps.MapCanvasProjection\n): PixelBounds => {\n  return {\n    northEast: projection.fromLatLngToDivPixel(bounds.getNorthEast()),\n    southWest: projection.fromLatLngToDivPixel(bounds.getSouthWest()),\n  };\n};\n\n/**\n * @hidden\n */\nexport const extendPixelBounds = (\n  { northEast, southWest }: PixelBounds,\n  pixels: number\n): PixelBounds => {\n  northEast.x += pixels;\n  northEast.y -= pixels;\n\n  southWest.x -= pixels;\n  southWest.y += pixels;\n\n  return { northEast, southWest };\n};\n\n/**\n * @hidden\n */\nexport const pixelBoundsToLatLngBounds = (\n  { northEast, southWest }: PixelBounds,\n  projection: google.maps.MapCanvasProjection\n): google.maps.LatLngBounds => {\n  const bounds = new google.maps.LatLngBounds();\n  bounds.extend(projection.fromDivPixelToLatLng(northEast));\n  bounds.extend(projection.fromDivPixelToLatLng(southWest));\n  return bounds;\n};\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Cluster } from \"../cluster\";\nimport { filterMarkersToPaddedViewport } from \"./utils\";\n\nexport interface AlgorithmInput {\n  /**\n   * The map containing the markers and clusters.\n   */\n  map: google.maps.Map;\n  /**\n   * An array of markers to be clustered.\n   *\n   * There are some specific edge cases to be aware of including the following:\n   * * Markers that are not visible.\n   */\n  markers: google.maps.Marker[];\n  /**\n   * The `mapCanvasProjection` enables easy conversion from lat/lng to pixel.\n   *\n   * @see [MapCanvasProjection](https://developers.google.com/maps/documentation/javascript/reference/overlay-view#MapCanvasProjection)\n   */\n  mapCanvasProjection: google.maps.MapCanvasProjection;\n}\n\nexport interface AlgorithmOutput {\n  /**\n   * The clusters returned based upon the {@link AlgorithmInput}.\n   */\n  clusters: Cluster[];\n  /**\n   * A boolean flag indicating that the clusters have not changed.\n   */\n  changed?: boolean;\n}\n\nexport interface Algorithm {\n  /**\n   * Calculates an array of {@link Cluster}.\n   */\n  calculate: ({ markers, map }: AlgorithmInput) => AlgorithmOutput;\n}\n\nexport interface AlgorithmOptions {\n  maxZoom?: number;\n}\n/**\n * @hidden\n */\nexport abstract class AbstractAlgorithm implements Algorithm {\n  protected maxZoom: number;\n\n  constructor({ maxZoom = 16 }: AlgorithmOptions) {\n    this.maxZoom = maxZoom;\n  }\n  /**\n   * Helper function to bypass clustering based upon some map state such as\n   * zoom, number of markers, etc.\n   *\n   * ```typescript\n   *  cluster({markers, map}: AlgorithmInput): Cluster[] {\n   *    if (shouldBypassClustering(map)) {\n   *      return this.noop({markers, map})\n   *    }\n   * }\n   * ```\n   */\n  protected noop({ markers }: AlgorithmInput): Cluster[] {\n    return noop(markers);\n  }\n  /**\n   * Calculates an array of {@link Cluster}. Calculate is separate from\n   * {@link cluster} as it does preprocessing on the markers such as filtering\n   * based upon the viewport as in {@link AbstractViewportAlgorithm}. Caching\n   * and other optimizations can also be done here.\n   */\n  public abstract calculate({ markers, map }: AlgorithmInput): AlgorithmOutput;\n\n  /**\n   * Clusters the markers and called from {@link calculate}.\n   */\n  protected abstract cluster({ markers, map }: AlgorithmInput): Cluster[];\n}\n\n/**\n * @hidden\n */\nexport interface ViewportAlgorithmOptions extends AlgorithmOptions {\n  /**\n   * The number of pixels to extend beyond the viewport bounds when filtering\n   * markers prior to clustering.\n   */\n  viewportPadding?: number;\n}\n\n/**\n * Abstract viewport algorithm proves a class to filter markers by a padded\n * viewport. This is a common optimization.\n *\n * @hidden\n */\nexport abstract class AbstractViewportAlgorithm extends AbstractAlgorithm {\n  protected viewportPadding = 60;\n\n  constructor({ viewportPadding = 60, ...options }: ViewportAlgorithmOptions) {\n    super(options);\n    this.viewportPadding = viewportPadding;\n  }\n  public calculate({\n    markers,\n    map,\n    mapCanvasProjection,\n  }: AlgorithmInput): AlgorithmOutput {\n    if (map.getZoom() >= this.maxZoom) {\n      return {\n        clusters: this.noop({\n          markers,\n          map,\n          mapCanvasProjection,\n        }),\n        changed: false,\n      };\n    }\n\n    return {\n      clusters: this.cluster({\n        markers: filterMarkersToPaddedViewport(\n          map,\n          mapCanvasProjection,\n          markers,\n          this.viewportPadding\n        ),\n        map,\n        mapCanvasProjection,\n      }),\n    };\n  }\n  protected abstract cluster({ markers, map }: AlgorithmInput): Cluster[];\n}\n\n/**\n * @hidden\n */\nexport const noop = (markers: google.maps.Marker[]): Cluster[] => {\n  const clusters = markers.map(\n    (marker) =>\n      new Cluster({\n        position: marker.getPosition(),\n        markers: [marker],\n      })\n  );\n  return clusters;\n};\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { AbstractAlgorithm, AlgorithmInput, AlgorithmOutput } from \"./core\";\nimport SuperCluster, { ClusterFeature } from \"supercluster\";\n\nimport { Cluster } from \"../cluster\";\nimport equal from \"fast-deep-equal\";\n\nexport type SuperClusterOptions = SuperCluster.Options<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  { [name: string]: any },\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  { [name: string]: any }\n>;\n\n/**\n * A very fast JavaScript algorithm for geospatial point clustering using KD trees.\n *\n * @see https://www.npmjs.com/package/supercluster for more information on options.\n */\nexport class SuperClusterAlgorithm extends AbstractAlgorithm {\n  protected superCluster: SuperCluster;\n  protected markers: google.maps.Marker[];\n  protected clusters: Cluster[];\n  protected state: { zoom: number };\n\n  constructor({ maxZoom, radius = 60, ...options }: SuperClusterOptions) {\n    super({ maxZoom });\n\n    this.superCluster = new SuperCluster({\n      maxZoom: this.maxZoom,\n      radius,\n      ...options,\n    });\n\n    this.state = { zoom: null };\n  }\n  public calculate(input: AlgorithmInput): AlgorithmOutput {\n    let changed = false;\n\n    if (!equal(input.markers, this.markers)) {\n      changed = true;\n      // TODO use proxy to avoid copy?\n      this.markers = [...input.markers];\n\n      const points = this.markers.map((marker) => {\n        return {\n          type: \"Feature\" as const,\n          geometry: {\n            type: \"Point\" as const,\n            coordinates: [\n              marker.getPosition().lng(),\n              marker.getPosition().lat(),\n            ],\n          },\n          properties: { marker },\n        };\n      });\n\n      this.superCluster.load(points);\n    }\n\n    const state = { zoom: input.map.getZoom() };\n\n    if (!changed) {\n      if (this.state.zoom > this.maxZoom && state.zoom > this.maxZoom) {\n        // still beyond maxZoom, no change\n      } else {\n        changed = changed || !equal(this.state, state);\n      }\n    }\n\n    this.state = state;\n\n    if (changed) {\n      this.clusters = this.cluster(input);\n    }\n\n    return { clusters: this.clusters, changed };\n  }\n\n  public cluster({ map }: AlgorithmInput): Cluster[] {\n    return this.superCluster\n      .getClusters([-180, -90, 180, 90], Math.round(map.getZoom()))\n      .map(this.transformCluster.bind(this));\n  }\n\n  protected transformCluster({\n    geometry: {\n      coordinates: [lng, lat],\n    },\n    properties,\n  }: ClusterFeature<{ marker: google.maps.Marker }>): Cluster {\n    if (properties.cluster) {\n      return new Cluster({\n        markers: this.superCluster\n          .getLeaves(properties.cluster_id, Infinity)\n          .map((leaf) => leaf.properties.marker),\n        position: new google.maps.LatLng({ lat, lng }),\n      });\n    } else {\n      const marker = properties.marker;\n\n      return new Cluster({\n        markers: [marker],\n        position: marker.getPosition(),\n      });\n    }\n  }\n}\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Cluster } from \"./cluster\";\n\n/**\n * Provides statistics on all clusters in the current render cycle for use in {@link Renderer.render}.\n */\nexport class ClusterStats {\n  public readonly markers: { sum: number };\n  public readonly clusters: {\n    count: number;\n    markers: {\n      mean: number;\n      sum: number;\n      min: number;\n      max: number;\n    };\n  };\n\n  constructor(markers: google.maps.Marker[], clusters: Cluster[]) {\n    this.markers = { sum: markers.length };\n\n    const clusterMarkerCounts = clusters.map((a) => a.count);\n    const clusterMarkerSum = clusterMarkerCounts.reduce((a, b) => a + b, 0);\n\n    this.clusters = {\n      count: clusters.length,\n      markers: {\n        mean: clusterMarkerSum / clusters.length,\n        sum: clusterMarkerSum,\n        min: Math.min(...clusterMarkerCounts),\n        max: Math.max(...clusterMarkerCounts),\n      },\n    };\n  }\n}\n\nexport interface Renderer {\n  /**\n   * Turn a {@link Cluster} into a `google.maps.Marker`.\n   *\n   * Below is a simple example to create a marker with the number of markers in the cluster as a label.\n   *\n   * ```typescript\n   * return new google.maps.Marker({\n   *   position,\n   *   label: String(markers.length),\n   * });\n   * ```\n   */\n  render(cluster: Cluster, stats: ClusterStats): google.maps.Marker;\n}\n\nexport class DefaultRenderer implements Renderer {\n  /**\n   * The default render function for the library used by {@link MarkerClusterer}.\n   *\n   * Currently set to use the following:\n   *\n   * ```typescript\n   * // change color if this cluster has more markers than the mean cluster\n   * const color =\n   *   count > Math.max(10, stats.clusters.markers.mean)\n   *     ? \"#ff0000\"\n   *     : \"#0000ff\";\n   *\n   * // create svg url with fill color\n   * const svg = window.btoa(`\n   * <svg fill=\"${color}\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 240 240\">\n   *   <circle cx=\"120\" cy=\"120\" opacity=\".6\" r=\"70\" />\n   *   <circle cx=\"120\" cy=\"120\" opacity=\".3\" r=\"90\" />\n   *   <circle cx=\"120\" cy=\"120\" opacity=\".2\" r=\"110\" />\n   *   <circle cx=\"120\" cy=\"120\" opacity=\".1\" r=\"130\" />\n   * </svg>`);\n   *\n   * // create marker using svg icon\n   * return new google.maps.Marker({\n   *   position,\n   *   icon: {\n   *     url: `data:image/svg+xml;base64,${svg}`,\n   *     scaledSize: new google.maps.Size(45, 45),\n   *   },\n   *   label: {\n   *     text: String(count),\n   *     color: \"rgba(255,255,255,0.9)\",\n   *     fontSize: \"12px\",\n   *   },\n   *   // adjust zIndex to be above other markers\n   *   zIndex: 1000 + count,\n   * });\n   * ```\n   */\n  public render(\n    { count, position }: Cluster,\n    stats: ClusterStats\n  ): google.maps.Marker {\n    // change color if this cluster has more markers than the mean cluster\n    const color =\n      count > Math.max(10, stats.clusters.markers.mean) ? \"#ff0000\" : \"#0000ff\";\n\n    // create svg url with fill color\n    const svg = window.btoa(`\n  <svg fill=\"${color}\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 240 240\">\n    <circle cx=\"120\" cy=\"120\" opacity=\".6\" r=\"70\" />\n    <circle cx=\"120\" cy=\"120\" opacity=\".3\" r=\"90\" />\n    <circle cx=\"120\" cy=\"120\" opacity=\".2\" r=\"110\" />\n  </svg>`);\n\n    // create marker using svg icon\n    return new google.maps.Marker({\n      position,\n      icon: {\n        url: `data:image/svg+xml;base64,${svg}`,\n        scaledSize: new google.maps.Size(45, 45),\n      },\n      label: {\n        text: String(count),\n        color: \"rgba(255,255,255,0.9)\",\n        fontSize: \"12px\",\n      },\n      title: `Cluster of ${count} markers`,\n      // adjust zIndex to be above other markers\n      zIndex: Number(google.maps.Marker.MAX_ZINDEX) + count,\n    });\n  }\n}\n","/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface OverlayViewSafe extends google.maps.OverlayView {}\n\n/**\n * Extends an object's prototype by another's.\n *\n * @param type1 The Type to be extended.\n * @param type2 The Type to extend with.\n * @ignore\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction extend(type1: any, type2: any): void {\n  /* istanbul ignore next */\n  // eslint-disable-next-line prefer-const\n  for (let property in type2.prototype) {\n    type1.prototype[property] = type2.prototype[property];\n  }\n}\n\n/**\n * @ignore\n */\nexport class OverlayViewSafe {\n  constructor() {\n    // MarkerClusterer implements google.maps.OverlayView interface. We use the\n    // extend function to extend MarkerClusterer with google.maps.OverlayView\n    // because it might not always be available when the code is defined so we\n    // look for it at the last possible moment. If it doesn't exist now then\n    // there is no point going ahead :)\n    extend(OverlayViewSafe, google.maps.OverlayView);\n  }\n}\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Algorithm, SuperClusterAlgorithm } from \"./algorithms\";\nimport { ClusterStats, DefaultRenderer, Renderer } from \"./renderer\";\n\nimport { Cluster } from \"./cluster\";\nimport { OverlayViewSafe } from \"./overlay-view-safe\";\n\nexport type onClusterClickHandler = (\n  event: google.maps.MapMouseEvent,\n  cluster: Cluster,\n  map: google.maps.Map\n) => void;\nexport interface MarkerClustererOptions {\n  markers?: google.maps.Marker[];\n  /**\n   * An algorithm to cluster markers. Default is {@link SuperClusterAlgorithm}. Must\n   * provide a `calculate` method accepting {@link AlgorithmInput} and returning\n   * an array of {@link Cluster}.\n   */\n  algorithm?: Algorithm;\n  map?: google.maps.Map | null;\n  /**\n   * An object that converts a {@link Cluster} into a `google.maps.Marker`.\n   * Default is {@link DefaultRenderer}.\n   */\n  renderer?: Renderer;\n  onClusterClick?: onClusterClickHandler;\n}\n\nexport enum MarkerClustererEvents {\n  CLUSTERING_BEGIN = \"clusteringbegin\",\n  CLUSTERING_END = \"clusteringend\",\n  CLUSTER_CLICK = \"click\",\n}\n\nexport const defaultOnClusterClickHandler: onClusterClickHandler = (\n  _: google.maps.MapMouseEvent,\n  cluster: Cluster,\n  map: google.maps.Map\n): void => {\n  map.fitBounds(cluster.bounds);\n};\n/**\n * MarkerClusterer creates and manages per-zoom-level clusters for large amounts\n * of markers. See {@link MarkerClustererOptions} for more details.\n *\n */\nexport class MarkerClusterer extends OverlayViewSafe {\n  /** @see {@link MarkerClustererOptions.onClusterClick} */\n  public onClusterClick: onClusterClickHandler;\n  /** @see {@link MarkerClustererOptions.algorithm} */\n  protected algorithm: Algorithm;\n  protected clusters: Cluster[];\n  protected markers: google.maps.Marker[];\n  /** @see {@link MarkerClustererOptions.renderer} */\n  protected renderer: Renderer;\n  /** @see {@link MarkerClustererOptions.map} */\n  protected map: google.maps.Map | null;\n  /** @see {@link MarkerClustererOptions.maxZoom} */\n  protected idleListener: google.maps.MapsEventListener;\n\n  constructor({\n    map,\n    markers = [],\n    algorithm = new SuperClusterAlgorithm({}),\n    renderer = new DefaultRenderer(),\n    onClusterClick = defaultOnClusterClickHandler,\n  }: MarkerClustererOptions) {\n    super();\n    this.markers = [...markers];\n    this.clusters = [];\n\n    this.algorithm = algorithm;\n    this.renderer = renderer;\n\n    this.onClusterClick = onClusterClick;\n\n    if (map) {\n      this.setMap(map);\n    }\n  }\n\n  public addMarker(marker: google.maps.Marker, noDraw?: boolean): void {\n    if (this.markers.includes(marker)) {\n      return;\n    }\n\n    this.markers.push(marker);\n    if (!noDraw) {\n      this.render();\n    }\n  }\n\n  public addMarkers(markers: google.maps.Marker[], noDraw?: boolean): void {\n    markers.forEach((marker) => {\n      this.addMarker(marker, true);\n    });\n\n    if (!noDraw) {\n      this.render();\n    }\n  }\n\n  public removeMarker(marker: google.maps.Marker, noDraw?: boolean): boolean {\n    const index = this.markers.indexOf(marker);\n\n    if (index === -1) {\n      // Marker is not in our list of markers, so do nothing:\n      return false;\n    }\n\n    marker.setMap(null);\n    this.markers.splice(index, 1); // Remove the marker from the list of managed markers\n\n    if (!noDraw) {\n      this.render();\n    }\n\n    return true;\n  }\n\n  public removeMarkers(\n    markers: google.maps.Marker[],\n    noDraw?: boolean\n  ): boolean {\n    let removed = false;\n\n    markers.forEach((marker) => {\n      removed = this.removeMarker(marker, true) || removed;\n    });\n\n    if (removed && !noDraw) {\n      this.render();\n    }\n\n    return removed;\n  }\n\n  public clearMarkers(noDraw?: boolean): void {\n    this.markers.length = 0;\n\n    if (!noDraw) {\n      this.render();\n    }\n  }\n\n  /**\n   * Recalculates and draws all the marker clusters.\n   */\n  public render(): void {\n    const map = this.getMap();\n    if (map instanceof google.maps.Map && this.getProjection()) {\n      google.maps.event.trigger(\n        this,\n        MarkerClustererEvents.CLUSTERING_BEGIN,\n        this\n      );\n      const { clusters, changed } = this.algorithm.calculate({\n        markers: this.markers,\n        map,\n        mapCanvasProjection: this.getProjection(),\n      });\n\n      // allow algorithms to return flag on whether the clusters/markers have changed\n      if (changed || changed == undefined) {\n        // reset visibility of markers and clusters\n        this.reset();\n\n        // store new clusters\n        this.clusters = clusters;\n\n        this.renderClusters();\n      }\n      google.maps.event.trigger(\n        this,\n        MarkerClustererEvents.CLUSTERING_END,\n        this\n      );\n    }\n  }\n\n  public onAdd(): void {\n    this.idleListener = this.getMap().addListener(\n      \"idle\",\n      this.render.bind(this)\n    );\n    this.render();\n  }\n\n  public onRemove(): void {\n    google.maps.event.removeListener(this.idleListener);\n    this.reset();\n  }\n\n  protected reset(): void {\n    this.markers.forEach((marker) => marker.setMap(null));\n    this.clusters.forEach((cluster) => cluster.delete());\n    this.clusters = [];\n  }\n\n  protected renderClusters(): void {\n    // generate stats to pass to renderers\n    const stats = new ClusterStats(this.markers, this.clusters);\n    const map = this.getMap() as google.maps.Map;\n\n    this.clusters.forEach((cluster) => {\n      if (cluster.markers.length === 1) {\n        cluster.marker = cluster.markers[0];\n      } else {\n        cluster.marker = this.renderer.render(cluster, stats);\n\n        if (this.onClusterClick) {\n          cluster.marker.addListener(\n            \"click\",\n            /* istanbul ignore next */\n            (event: google.maps.MapMouseEvent) => {\n              google.maps.event.trigger(\n                this,\n                MarkerClustererEvents.CLUSTER_CLICK,\n                cluster\n              );\n              this.onClusterClick(event, cluster, map);\n            }\n          );\n        }\n      }\n\n      cluster.marker.setMap(map);\n    });\n  }\n}\n","import { MarkerClusterer } from '@googlemaps/markerclusterer';\n\nexport function createMap(container) {\n  const map = new google.maps.Map(container, {\n    zoom: 16,\n    center: { lat: 50.3864813, lng: 30.4610184 },\n    mapTypeControl: true,\n    mapTypeControlOptions: {\n      style: google.maps.MapTypeControlStyle.HORIZONTAL_BAR,\n      position: google.maps.ControlPosition.TOP_CENTER,\n    },\n    zoomControl: true,\n    zoomControlOptions: {\n      position: google.maps.ControlPosition.LEFT_CENTER,\n    },\n    scaleControl: true,\n    streetViewControl: true,\n    streetViewControlOptions: {\n      position: google.maps.ControlPosition.LEFT_TOP,\n    },\n    fullscreenControl: true,\n  });\n\n  const mapObservers = [];\n\n  const addPoints = points => {\n    const markers = points.map(({ id, lat, lng }) => {\n      const label = id.toString();\n\n      const marker = new google.maps.Marker({\n        position: { lat, lng },\n        label,\n      });\n\n      // вынести колл-бек из лисенера - дать понятное имя\n      // убрать querySelector (document) устранить выход из контекста\n      // 18 - константа зума: сделать константой с понятным именем \"масштаб крупный (уменьшеный)\"\n\n      marker.addListener('click', mapsMouseEvent => {\n        map.setZoom(18);\n        map.setCenter(marker.position);\n\n        const appartByClickMarketEl = document.querySelector(\n          `[data-id='${marker.label}']`\n        );\n        appartByClickMarketEl.scrollIntoView(true);\n      });\n\n      return marker;\n    });\n\n    new MarkerClusterer({ markers, map });\n  };\n\n  map.addListener('bounds_changed', boundsChanged);\n\n  setTimeout(() => {\n    console.log('get bounds', map.getBounds().toJSON());\n  }, 3000);\n\n  // разносить подписчиков по типу ивента на этапе подписки\n\n  function boundsChanged() {\n    for (let i = 0; i < mapObservers.length; i++) {\n      if (mapObservers[i].eventName === 'bounds_changed') {\n        mapObservers[i].listener(map.getBounds().toJSON());\n      }\n    }\n  }\n\n  const findNewPoints = request => {\n    return new Promise((resolve, reject) => {\n      var service = new google.maps.places.PlacesService(map);\n\n      service.findPlaceFromQuery(request, function (results, status) {\n        if (status === google.maps.places.PlacesServiceStatus.OK) {\n          createMarker(results[0]);\n          const newPointCoordinates = {\n            lat: results[0].geometry.location.lat(),\n            lng: results[0].geometry.location.lng(),\n          };\n\n          map.setCenter(results[0].geometry.location);\n          resolve(newPointCoordinates);\n        } else {\n          reject(status);\n        }\n      });\n\n      function createMarker(place) {\n        if (!place.geometry || !place.geometry.location) return;\n\n        const marker = new google.maps.Marker({\n          map,\n          position: place.geometry.location,\n        });\n      }\n    });\n  };\n\n  function addEventListener(eventName, listener) {\n    mapObservers.push({ eventName, listener });\n  }\n\n  function removeEventListener(eventName, handler) {}\n\n  return {\n    addPoints,\n    findNewPoints,\n    zoomTo: () => {},\n    addEventListener,\n    removeEventListener,\n  };\n}\n\n//-----------------------------------\n","export class Gallery {\n  itemsGalleryEl = '';\n\n  constructor(root) {\n    this.itemsGalleryEl = document.querySelector(root);\n  }\n\n  renderItemsGallery = appartments => {\n    return appartments\n      .map(appart => {\n        return `\n    <li class=\"item\" data-id=\"${appart.id}\">\n    <img class=\"item--img\" src=\"${appart.image}\" alt=\"\" />\n    <div class=\"item--details\">\n      <h3 class=\"item--title\">${appart.title}</h3>\n      <p class=\"item--description\">${appart.description}</p>\n    </div>\n  </li>\n    `;\n      })\n      .join('');\n  };\n\n  showAppartments = appartments => {\n    this.itemsGalleryEl.innerHTML = this.renderItemsGallery(appartments);\n  };\n\n  hideGallery = () => {\n    this.itemsGalleryEl.classList.add('invisible');\n  };\n\n  openGallery = () => {\n    this.itemsGalleryEl.classList.remove('invisible');\n  };\n}\n","export class Form {\n  rootEl = '';\n  ref = {\n    inputAddress: '',\n    inputImageLink: '',\n    inputDescripton: '',\n    buttonSearch: '',\n    stepAdd: [],\n  };\n\n  constructor(root) {\n    this.rootEl = document.querySelector(root);\n    this.hideForm();\n  }\n\n  renderFormToAddNewAppartment = (onSubmitSearch, onSubmitAdd) => {\n    this.rootEl.innerHTML = `\n<div class=\"form__wrap\">\n  <h3 class=\"form__title\">Додайте новий об'єкт</h3>\n  <form class=\"form__body\">\n    <label class=\"form__label\">\n      <span class=\"form__text\">Адреса</span>\n      <input class=\"form__field\" type=\"text\" name=\"title\" placeholder=\"назва вулиці, № будинку\" />\n    </label>\n\n    <label class=\"form__label\">\n      <span class=\"form__text invisible\" option=\"stepAdd\">Посилання на фото</span>\n      <input class=\"form__field invisible\" type=\"text\" name=\"image\" option=\"stepAdd\" placeholder=\"посилання на фото\" />\n    </label>\n\n    <label class=\"form__label \">\n      <span class=\"form__text invisible\" option=\"stepAdd\">Опис</span>\n      <textarea\n        class=\"form__field form__field--textarea invisible\"\n        name=\"description\"\n        option=\"stepAdd\"\n        placeholder=\"опис об'єкту\"\n        cols=\"30\"\n        rows=\"10\"\n      ></textarea>\n    </label>\n    <button class=\"form__button form__button--search\" option='step1'>Знайти адресу</button>\n    <button class=\"form__button form__button--save invisible\" type=\"submit\" option='stepAdd'>Додати</button>\n    <div class='form__error'>\n    <p class='error__text--not-found invisible'>Об'єкт не знайдено. Спробуйте ще</p>\n    <p class='error__text--empty-fields invisible'>Заповніть всі поля</p>\n    </div>\n\n  </form>\n</div>\n`;\n    this.ref.inputAddress = this.rootEl.querySelector('input[name=\"title\"]');\n    this.ref.inputImageLink = this.rootEl.querySelector('input[name=\"image\"]');\n    this.ref.inputDescripton = this.rootEl.querySelector(\n      '[name=\"description\"]'\n    );\n    this.ref.buttonSearch = this.rootEl.querySelector('.form__button--search');\n    this.ref.stepAdd = this.rootEl.querySelectorAll('[option=\"stepAdd\"]');\n\n    this.ref.inputAddress.addEventListener('focus', () => {\n      this.ref.inputAddress.value = '';\n      this.hideErrorSearch();\n    });\n\n    this.rootEl\n      .querySelector('.form__button--search')\n      .addEventListener('click', event => {\n        event.preventDefault();\n\n        const title = this.ref.inputAddress.value;\n        onSubmitSearch(title);\n      });\n\n    this.rootEl\n      .querySelector('.form__body')\n      .addEventListener('submit', event => {\n        event.preventDefault();\n\n        const title = event.currentTarget.elements['title'].value;\n        const image = event.currentTarget.elements['image'].value;\n        const description = event.currentTarget.elements['description'].value;\n        onSubmitAdd({ title, image, description });\n      });\n  };\n\n  openFormAfterSearch = () => {\n    this.ref.buttonSearch.classList.add('invisible');\n    this.ref.stepAdd.forEach(item => item.classList.remove('invisible'));\n  };\n\n  hideFormAfterSearch = () => {\n    this.ref.inputAddress.value = '';\n    this.ref.inputImageLink.value = '';\n    this.ref.inputDescripton.value = '';\n    this.ref.buttonSearch.classList.remove('invisible');\n    this.ref.stepAdd.forEach(item => item.classList.add('invisible'));\n  };\n\n  hideForm = () => {\n    this.rootEl.classList.add('invisible');\n  };\n\n  openForm = () => {\n    this.rootEl.classList.remove('invisible');\n  };\n\n  hideErrorSearch = () => {\n    this.rootEl\n      .querySelector('.error__text--not-found')\n      .classList.add('invisible');\n  };\n\n  showErrorSearch = () => {\n    this.rootEl\n      .querySelector('.error__text--not-found')\n      .classList.remove('invisible');\n  };\n}\n","import { ModelObjectHandler } from './modelObjectsHandler';\nimport { createMap } from './createMap';\nimport { Gallery } from './createGallery';\nimport { Form } from './createForm';\n\nfunction main() {\n  const model = new ModelObjectHandler();\n  model.initModel();\n\n  const map = createMap(document.getElementById('map'));\n  const gallery = new Gallery('.item__list');\n  const form = new Form('.form__block');\n\n  // btn -> button + ENG rule - \"El\"\n  //document.querySelector + -- __\n\n  const btnAddNewAppartmentEl = document.querySelector('.header--btn');\n  btnAddNewAppartmentEl.addEventListener('click', form.openForm);\n  btnAddNewAppartmentEl.addEventListener('click', gallery.hideGallery);\n\n  map.addPoints(model.getAllPoints());\n\n  function onBoundsChange(bounds) {\n    const visiblePoints = model.getVisiblePointsId(bounds);\n    gallery.showAppartments(model.getAppartmentsByIdArr(visiblePoints));\n  }\n\n  map.addEventListener('bounds_changed', onBoundsChange);\n\n  // отказаться от Буфера. каждому шагу свой зен. передавать коордтнаты в скрытое поле формы\n\n  const prepareNewPointAndNewAppartmentForm = newPointCoordinates => {\n    model.initBuffer(model.getLastPointId(), newPointCoordinates);\n\n    form.openFormAfterSearch();\n  };\n\n  const searchOnMap = title => {\n    const fields = ['name', 'geometry'];\n    map\n      .findNewPoints({ fields, query: title })\n      .then(prepareNewPointAndNewAppartmentForm)\n      .catch(form.showErrorSearch);\n  };\n\n  const prepareNewAppartment = ({ title, image, description }) => {\n    model.addAppartmentToBuffer({ title, image, description });\n    model.addNewAppartment(model.bufferObj);\n\n    form.hideFormAfterSearch();\n    form.hideForm();\n\n    gallery.openGallery();\n    gallery.showAppartments(model.getAppartmentById(model.bufferObj.id));\n  };\n\n  form.renderFormToAddNewAppartment(searchOnMap, prepareNewAppartment);\n}\n\nwindow.main = main;\n//window.initMap = initMap;\n"],"names":["Object","defineProperty","$da4b248c00322402$exports","value","default","obj","key","enumerable","configurable","writable","$b11092b003750ebb$export$9f048bf86ee2e9d2","id","lat","lng","$b11092b003750ebb$export$2f533e9e2cb0c822","title","image","description","$cdbab5c228e4456d$export$510885540657d15b","$parcel$interopDefault","this","JSON","parse","localStorage","getItem","setItem","stringify","pnts","length","apparts","findIndex","appartment","idArr","filter","includes","rectangle","$cdbab5c228e4456d$var$isInBounds","map","$cdbab5c228e4456d$var$getPointId","lastPointId","bufferObj","status","push","point","south","north","west","east","$34dec55abe625cc9$export$2e2bcd8739ae039","ids","coords","nodeSize","left","right","depth","m","$34dec55abe625cc9$var$select","k","inc","n","z","Math","log","s","exp","sd","sqrt","max","floor","min","t","i","j","$34dec55abe625cc9$var$swapItem","$34dec55abe625cc9$var$swap","arr","tmp","$878615e4b096134c$export$2e2bcd8739ae039","minX","minY","maxX","maxY","stack","result","x","y","axis","pop","nextAxis","$a70968a20ae4342b$export$2e2bcd8739ae039","qx","qy","r","r2","$a70968a20ae4342b$var$sqDist","ax","ay","bx","by","dx","dy","$da9c10bf0d633d8b$exports","equal","a","b","constructor","keys","Array","isArray","RegExp","source","flags","valueOf","prototype","toString","hasOwnProperty","call","$91a4b9ada9dcd4fc$var$defaultGetX","p","$91a4b9ada9dcd4fc$var$defaultGetY","$91a4b9ada9dcd4fc$export$2e2bcd8739ae039","range","within","points","getX","getY","ArrayType","Float64Array","IndexArrayType","Uint16Array","Uint32Array","$6a3d15a5d50a20dd$var$defaultOptions","minZoom","maxZoom","minPoints","radius","extent","generateId","reduce","props","$6a3d15a5d50a20dd$var$fround","fround","Float32Array","$6a3d15a5d50a20dd$export$2e2bcd8739ae039","load","options","console","time","timerId","clusters","geometry","$6a3d15a5d50a20dd$var$createPointCluster","trees","$6a3d15a5d50a20dd$var$getX","$6a3d15a5d50a20dd$var$getY","timeEnd","now","Date","_cluster","getClusters","bbox","zoom","minLng","minLat","maxLng","maxLat","easternHem","westernHem","concat","tree","_limitZoom","$6a3d15a5d50a20dd$var$lngX","$6a3d15a5d50a20dd$var$latY","c","numPoints","$6a3d15a5d50a20dd$var$getClusterJSON","index","getChildren","clusterId","originId","_getOriginId","originZoom","_getOriginZoom","errorMsg","Error","origin","pow","children","parentId","getLeaves","limit","offset","leaves","_appendLeaves","getTile","z2","top","bottom","tile","features","_addTileFeatures","getClusterExpansionZoom","expansionZoom","properties","cluster_id","skipped","child","cluster","point_count","isCluster","tags","px","py","$6a3d15a5d50a20dd$var$getClusterProperties","coordinates","f","type","round","undefined","neighborIds","numPointsOrigin","neighborId","wx","wy","clusterProperties","_map","numPoints2","$6a3d15a5d50a20dd$var$createCluster","clone","$6a3d15a5d50a20dd$var$extend","original","create","Infinity","$6a3d15a5d50a20dd$var$yLat","count","abbrev","point_count_abbreviated","sin","PI","y2","atan","dest","src","$dde19cd987ee6d6e$export$57ed47926628b770","bounds","markers","_position","extend","marker","getPosition","google","maps","LatLngBounds","position","getVisible","delete","setMap","$dde19cd987ee6d6e$export$1e1bee200f7e743e","noop","$dde19cd987ee6d6e$export$8793edee2d425525","input","state","getZoom","changed","superCluster","transformCluster","bind","leaf","LatLng","_a","$dde19cd987ee6d6e$var$__rest","sum","clusterMarkerCounts","clusterMarkerSum","stats","mean","svg","window","btoa","Marker","icon","url","scaledSize","Size","type1","type2","property","$dde19cd987ee6d6e$export$f87b0506a2cf0bc","MarkerClustererEvents1","$dde19cd987ee6d6e$export$b434dc9855552644","_","fitBounds","$dde19cd987ee6d6e$export$58bd9bb9fcf3dd4f","$dde19cd987ee6d6e$var$OverlayViewSafe","noDraw","render","forEach","addMarker","indexOf","splice","removed","removeMarker","getMap","Map","getProjection","event","trigger","CLUSTERING_BEGIN","algorithm","calculate","mapCanvasProjection","reset","renderClusters","CLUSTERING_END","onAdd","removeListener","idleListener","$dde19cd987ee6d6e$export$2deda6e6beba3286","renderer","onClusterClick","addListener","CLUSTER_CLICK","$786b15bc02cd6cc2$export$d49c9aa30b771d59","container","center","mapTypeControl","mapTypeControlOptions","style","MapTypeControlStyle","HORIZONTAL_BAR","ControlPosition","TOP_CENTER","zoomControl","zoomControlOptions","LEFT_CENTER","scaleControl","streetViewControl","streetViewControlOptions","LEFT_TOP","fullscreenControl","mapObservers","eventName","listener","getBounds","toJSON","setTimeout","label","mapsMouseEvent","setZoom","setCenter","document","querySelector","scrollIntoView","request","Promise","resolve","reject","places","PlacesService","findPlaceFromQuery","results","PlacesServiceStatus","OK","place","location","createMarker","newPointCoordinates","zoomTo","handler","$84c4c517af77e8fa$export$ace63239d21d36e","root","appartments","appart","join","itemsGalleryEl","innerHTML","renderItemsGallery","classList","add","remove","$6704978bad493937$export$a7fed597f4b8afd8","inputAddress","inputImageLink","inputDescripton","buttonSearch","stepAdd","onSubmitSearch","onSubmitAdd","rootEl","ref","querySelectorAll","addEventListener","hideErrorSearch","preventDefault","currentTarget","elements","item","hideForm","main","model","initModel","getElementById","gallery","form","btnAddNewAppartmentEl","openForm","hideGallery","addPoints","getAllPoints","visiblePoints","getVisiblePointsId","showAppartments","getAppartmentsByIdArr","prepareNewPointAndNewAppartmentForm","initBuffer","getLastPointId","openFormAfterSearch","renderFormToAddNewAppartment","findNewPoints","query","then","catch","showErrorSearch","addAppartmentToBuffer","addNewAppartment","hideFormAfterSearch","openGallery","getAppartmentById"],"version":3,"file":"index.a01bde33.js.map"}